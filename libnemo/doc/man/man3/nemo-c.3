.TH nemo-c 3 "Mar 2010" "" "Nemo Reference Manual"
.ad l
.nh
.SH NAME
nemo-c \- 
.PP
C API for the nemo spiking neural network simulator.  

.SH SYNOPSIS
.br
.PP
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void * \fBnemo_network_t\fP"
.br
.ti -1c
.RI "typedef int \fBnemo_status_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_cuda_device_count\fP (unsigned *count)"
.br
.in -1c
.PP
.RI "\fBConfiguration\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "NEMO_DLL_PUBLIC nemo_configuration_t \fBnemo_new_configuration\fP ()"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_log_stdout\fP (nemo_configuration_t)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_set_stdp_function\fP (nemo_configuration_t, float prefire_fn[], size_t prefire_len, float postfire_fn[], size_t postfire_len, float min_weight, float max_weight)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_set_cpu_backend\fP (nemo_configuration_t, int thread_count)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_cpu_thread_count\fP (nemo_configuration_t conf, int *thread_count)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_set_cuda_backend\fP (nemo_configuration_t conf, int dev)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_cuda_device\fP (nemo_configuration_t conf, int *dev)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_backend\fP (nemo_configuration_t conf, backend_t *backend)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_backend_description\fP (nemo_configuration_t conf, const char **descr)"
.br
.in -1c
.in -1c
.PP
.RI "\fBConstruction\fP"
.br
 Networks are constructed by adding individual neurons, and single or groups of synapses to the network. Neurons are given indices (from 0) which should be unique for each neuron. When adding synapses the source or target neurons need not necessarily exist yet, but should be defined before the network is finalised. 
.PP
.in +1c
.in +1c
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_network_t\fP \fBnemo_new_network\fP ()"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_add_neuron\fP (\fBnemo_network_t\fP, unsigned idx, float a, float b, float c, float d, float u, float v, float sigma)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_add_synapse\fP (\fBnemo_network_t\fP, unsigned source, unsigned target, unsigned delay, float weight, unsigned char is_plastic, synapse_id *id)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_neuron_count\fP (\fBnemo_network_t\fP net, unsigned *ncount)"
.br
.in -1c
.in -1c
.PP
.RI "\fBSimulation\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "NEMO_DLL_PUBLIC nemo_simulation_t \fBnemo_new_simulation\fP (\fBnemo_network_t\fP, nemo_configuration_t)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_step\fP (nemo_simulation_t, unsigned fstim_nidx[], size_t fstim_count, unsigned istim_nidx[], float istim_current[], size_t istim_count, unsigned *fired[], size_t *fired_count)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_apply_stdp\fP (nemo_simulation_t, float reward)"
.br
.in -1c
.in -1c
.PP
.RI "\fBSimulation (queries)\fP"
.br
 The synapse state can be read back at run-time by specifiying a list of synpase ids (
.PP
\fBSee also:\fP
.RS 4
addSynapse). The weights may change at run-time, while the other synapse data is static. 
.RE
.PP

.PP
.in +1c
.in +1c
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_get_membrane_potential\fP (nemo_simulation_t sim, unsigned neuron, float *v)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_set_neuron\fP (nemo_simulation_t sim, unsigned idx, float a, float b, float c, float d, float u, float v, float sigma)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_get_targets\fP (nemo_simulation_t ptr, synapse_id synapses[], size_t len, unsigned *targets[])"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_get_delays\fP (nemo_simulation_t ptr, synapse_id synapses[], size_t len, unsigned *delays[])"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_get_weights\fP (nemo_simulation_t ptr, synapse_id synapses[], size_t len, float *weights[])"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_get_plastic\fP (nemo_simulation_t ptr, synapse_id synapses[], size_t len, unsigned char *plastic[])"
.br
.in -1c
.in -1c
.PP
.RI "\fBSimulation (timing)\fP"
.br
 The simulation has two internal timers which keep track of the elapsed \fIsimulated\fP time and \fIwallclock\fP time. Both timers measure from the first simulation step, or from the last timer reset, whichever comes last. 
.PP
.in +1c
.in +1c
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_elapsed_wallclock\fP (nemo_simulation_t, unsigned long *)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_elapsed_simulation\fP (nemo_simulation_t, unsigned long *)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC \fBnemo_status_t\fP \fBnemo_reset_timer\fP (nemo_simulation_t)"
.br
.in -1c
.in -1c
.PP
.RI "\fBError handling\fP"
.br
 The API functions generally return an error status of type \fBnemo_status_t\fP. A non-zero value indicates an error. An error string describing this error is stored internally and can be queried by the user. 
.PP
.in +1c
.in +1c
.ti -1c
.RI "NEMO_DLL_PUBLIC const char * \fBnemo_strerror\fP ()"
.br
.in -1c
.in -1c
.PP
.RI "\fBFinalization\fP"
.br
 
.PP
.in +1c
.in +1c
.ti -1c
.RI "NEMO_DLL_PUBLIC void \fBnemo_delete_network\fP (\fBnemo_network_t\fP)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC void \fBnemo_delete_configuration\fP (nemo_configuration_t)"
.br
.ti -1c
.RI "NEMO_DLL_PUBLIC void \fBnemo_delete_simulation\fP (nemo_simulation_t)"
.br
.in -1c
.in -1c
.SH "Detailed Description"
.PP 
C API for the nemo spiking neural network simulator. 


.SH "Typedef Documentation"
.PP 
.SS "typedef void* \fBnemo_network_t\fP"Only opaque pointers are exposed in the C API 
.SS "typedef int \fBnemo_status_t\fP"Status of API calls which can fail. 
.SH "Function Documentation"
.PP 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_cuda_device_count (unsigned * count)"\fBReturns:\fP
.RS 4
number of CUDA devices on this system.
.RE
.PP
In case of error sets device count to 0 and return an error code. The associated error message can read using nemo_strerror. Errors can be the result of missing CUDA libraries, which from the users point of view may or may not be considered an error 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_log_stdout (nemo_configuration_t)" 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_set_stdp_function (nemo_configuration_t, float prefire_fn[], size_t prefire_len, float postfire_fn[], size_t postfire_len, float min_weight, float max_weight)"Enable spike-timing dependent plasticity in the simulation.
.PP
\fBParameters:\fP
.RS 4
\fIprefire_fn\fP STDP function sampled at integer cycle intervals in the prefire part of the STDP window 
.br
\fIprefire_len\fP Length, in cycles, of the part of the STDP window that precedes the postsynaptic firing. 
.br
\fIpostfire_fn\fP STDP function sampled at integer cycle intervals in the postfire part of the STDP window 
.br
\fIpostfire_len\fP Length, in cycles, of the part of the STDP window that comes after the postsynaptic firing. 
.br
\fImin_weight\fP Weight beyond which inhibitory synapses are not allowed to move 
.br
\fImax_weight\fP Weight beyond which excitatory synapses are not allowed to move 
.RE
.PP

.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_set_cpu_backend (nemo_configuration_t, int thread_count)"Specify that the CPU backend should be used and optionally specify the number of threads to use. If the default thread count of -1 is used, the backend will choose a sensible value  
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_cpu_thread_count (nemo_configuration_t conf, int * thread_count)"\fBReturns:\fP
.RS 4
the number of threads used by the CPU backend or -1 if CPU is not the selected backend. 
.RE
.PP
 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_set_cuda_backend (nemo_configuration_t conf, int dev)"Specify that the CUDA backend should be used and optionally specify a desired device. If the (default) device value of -1 is used the backend will choose the best available device.
.PP
If the cuda backend (and the chosen device) cannot be used for whatever reason, an exception is raised.
.PP
The device numbering is the numbering used internally by nemo (
.PP
\fBSee also:\fP
.RS 4
\fIcudaDeviceCount\fP and \fIcudaDeviceDescription\fP). This device numbering may differ from the one provided by the CUDA driver directly, since nemo ignores any devices it cannot use. 
.RE
.PP
 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_backend (nemo_configuration_t conf, backend_t * backend)" 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_backend_description (nemo_configuration_t conf, const char ** descr)"\fBReturns:\fP
.RS 4
description of the chosen backend 
.RE
.PP
 
.SS "NEMO_DLL_PUBLIC \fBnemo_network_t\fP nemo_new_network ()"Create an empty network object 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_add_neuron (\fBnemo_network_t\fP, unsigned idx, float a, float b, float c, float d, float u, float v, float sigma)"Add a single neuron to the network
.PP
The neuron uses the Izhikevich neuron model. See E. M. Izhikevich 'Simple model of spiking neurons', \fIIEEE\fP \fITrans\fP. \fINeural\fP \fINetworks\fP, vol 14, pp 1569-1572, 2003 for a full description of the model and the parameters.
.PP
\fBParameters:\fP
.RS 4
\fIidx\fP Neuron index. This should be unique 
.br
\fIa\fP Time scale of the recovery variable \fIu\fP 
.br
\fIb\fP Sensitivity to sub-threshold fluctutations in the membrane potential \fIv\fP 
.br
\fIc\fP After-spike reset value of the membrane potential \fIv\fP 
.br
\fId\fP After-spike reset of the recovery variable \fIu\fP 
.br
\fIu\fP Initial value for the membrane recovery variable 
.br
\fIv\fP Initial value for the membrane potential 
.br
\fIsigma\fP Parameter for a random gaussian per-neuron process which generates random input current drawn from an N(0,\fIsigma\fP) distribution. If set to zero no random input current will be generated. 
.RE
.PP
 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_add_synapse (\fBnemo_network_t\fP, unsigned source, unsigned target, unsigned delay, float weight, unsigned char is_plastic, synapse_id * id)"
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_step (nemo_simulation_t, unsigned fstim_nidx[], size_t fstim_count, unsigned istim_nidx[], float istim_current[], size_t istim_count, unsigned * fired[], size_t * fired_count)"Run simulation for a single cycle (1ms)
.PP
Neurons can be optionally be forced to fire using the two arguments
.PP
\fBParameters:\fP
.RS 4
\fIfstim_nidx\fP Indices of the neurons which should be forced to fire this cycle. 
.br
\fIfstim_count\fP Length of \fIfstim_nidx\fP 
.br
\fIistim_nidx\fP Indices of neurons which should receive external current stimulus this cycle. 
.br
\fIistim_current\fP The corresponding vector of current 
.br
\fIistim_count\fP Length of \fIistim_nidx\fP *and* \fIistim_current\fP 
.br
\fIfired\fP (output) Vector which fill be filled with the indices of the neurons which fired this cycle. Set to NULL if the firing output is ignored. 
.br
\fIfired_count\fP (output) Number of neurons which fired this cycle, i.e. the length of \fIfired\fP. Set to NULL if the firing output is ignored. 
.RE
.PP

.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_apply_stdp (nemo_simulation_t, float reward)"Update synapse weights using the accumulated STDP statistics
.PP
\fBParameters:\fP
.RS 4
\fIreward\fP Multiplier for the accumulated weight change 
.RE
.PP
 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_set_neuron (nemo_simulation_t sim, unsigned idx, float a, float b, float c, float d, float u, float v, float sigma)"Modify the parameters/state for a single neuron at run-time
.PP
The neuron must already exist.
.PP
\fBSee also:\fP
.RS 4
\fBnemo_add_neuron\fP for parameters 
.RE
.PP

.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_get_targets (nemo_simulation_t ptr, synapse_id synapses[], size_t len, unsigned * targets[])"Get synapse target for the specified synapses
.PP
\fBParameters:\fP
.RS 4
\fIsynapses\fP list of synapse ids (
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnemo_add_synapse\fP) 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlen\fP length of \fIsynapses\fP 
.br
\fItargets\fP (output) vector of length \fIlen\fP to be set with synapse state. The memory is managed by the simulation object and is valid until the next call to this function. 
.RE
.PP

.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_get_delays (nemo_simulation_t ptr, synapse_id synapses[], size_t len, unsigned * delays[])"Get conductance delays for the specified synapses
.PP
\fBParameters:\fP
.RS 4
\fIsynapses\fP list of synapse ids (
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnemo_add_synapse\fP) 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlen\fP length of \fIsynapses\fP 
.br
\fIdelays\fP (output) vector of length \fIlen\fP to be set with synapse state. The memory is managed by the simulation object and is valid until the next call to this function. 
.RE
.PP

.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_get_weights (nemo_simulation_t ptr, synapse_id synapses[], size_t len, float * weights[])"Get weights for the specified synapses
.PP
\fBParameters:\fP
.RS 4
\fIsynapses\fP list of synapse ids (
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnemo_add_synapse\fP) 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlen\fP length of \fIsynapses\fP 
.br
\fIweights\fP (output) vector of length \fIlen\fP to be set with synapse state. The memory is managed by the simulation object and is valid until the next call to this function. 
.RE
.PP

.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_get_plastic (nemo_simulation_t ptr, synapse_id synapses[], size_t len, unsigned char * plastic[])"Get boolean plasticity status for the specified synapses
.PP
\fBParameters:\fP
.RS 4
\fIsynapses\fP list of synapse ids (
.RE
.PP
\fBSee also:\fP
.RS 4
\fBnemo_add_synapse\fP) 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlen\fP length of \fIsynapses\fP 
.br
\fIweights\fP (output) vector of length \fIlen\fP to be set with synapse state. The memory is managed by the simulation object and is valid until the next call to this function. 
.RE
.PP

.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_elapsed_wallclock (nemo_simulation_t, unsigned long *)" 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_elapsed_simulation (nemo_simulation_t, unsigned long *)" 
.SS "NEMO_DLL_PUBLIC \fBnemo_status_t\fP nemo_reset_timer (nemo_simulation_t)" 
.SS "NEMO_DLL_PUBLIC const char* nemo_strerror ()"\fBReturns:\fP
.RS 4
string describing the most recent error (if any) 
.RE
.PP

.SS "NEMO_DLL_PUBLIC void nemo_delete_network (\fBnemo_network_t\fP)"Delete network object, freeing up all its associated resources 
.SS "NEMO_DLL_PUBLIC void nemo_delete_simulation (nemo_simulation_t)"Delete simulation object, freeing up all its associated resources 
.SH SEE ALSO
nemo(3) for library overview
.SH AUTHOR
.PP 
Andreas Fidjeland (using Doxygen)
