\documentclass[a4paper]{article}

\usepackage{graphicx}
\usepackage{listings}
\usepackage[colorlinks=true]{hyperref}
\usepackage{amsmath}
\usepackage{color}

%\usepackage{multitoc}

\setlength{\parindent}{0pt} 
\setlength{\parskip}{2ex}

\definecolor{light-gray}{gray}{0.8}

\lstset{
	tabsize=2,
	basicstyle=\small \ttfamily,
	%basicstyle=\small \ttfamily,
	%basicstyle={\rmfamily},
	%basicstyle={\ttfamily},
	%numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	frame=single,
	framerule=0pt,
	backgroundcolor=\color{light-gray}
}

\lstnewenvironment
	{matlab}
	{ 	\lstset{
			language=Matlab,
			% basicstyle=\small \ttfamily,
			numbers=none
	}	}
	{ }

\lstnewenvironment
	{ccode}
	{ 	\lstset{
			language=C,
			% basicstyle=\small \ttfamily,
			numbers=none
	}	}
	{ }

\lstnewenvironment
	{shell}
	{ 	\lstset{
			%language=Matlab,
			%basicstyle=\small \ttfamily,
			basicstyle={\ttfamily},
			numbers=none
	}	}
	{ }


\newcommand{\nemo}{\texttt{NeMo}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\command}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{#1}}
\newcommand{\directory}[1]{\texttt{#1}}
\newcommand{\library}[1]{\texttt{#1}}

% rst2latex leaves in title references
\newcommand{\titlereference}[1]{\textsl{#1}}

\newcommand{\cpp}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\tiny\bf +}\nolinebreak\hspace{-.10em}\raisebox{.4ex}{\tiny\bf +}}

% rst2latex also sets this on inside the document
\newlength{\locallinewidth}

\input{title}

\begin{document}

\maketitle

\begin{abstract}

\nemo\ is a library for discrete-time simulation of spiking neural networks. 
It is aimed at real-time simulation of tens of thousands of neurons on a single workstation.
\nemo\ runs on parallel hardware;
	In particular it can run on CUDA-enabled GPUs.
No parallel programming is required, however, on the part of the end user,
	as parallelisation is handled by the library.
The library has interfaces in \cpp, C, Python, and Matlab.

\end{abstract}

%\tableofcontents
%\newpage


\section{A short tutorial introduction}

The \nemo\ library can be used to simulate a network of neurons based on the
	Izhikevich neuron model \cite{izhikevich2003simple_model}.
The library exposes three basic types of objects:
	network, configuration, and simulation.
Setting up and running such a simulation involves:

\begin{enumerate}
	\item Creating a network object and adding neurons and synapses;
	\item Creating a configuration object and setting its parameters as appropriate;
	\item Creating a simulation object from the network and configuration objects and running the simulation.
\end{enumerate}

The following section shows basic usage of the library using the \cpp\ interface.
The other language interfaces (Section~\ref{api}) have very similar usage.

\subsection{Constructing a network}

Network construction is performed using a low-level interface
	where neurons and synapses are added individually.
Higher-level construction interfaces,
	e.g. using various forms of projections,
	can be built on top of this,
	but is not part of \nemo.

First create an empty network and add a few neurons:

\begin{ccode}
nemo::Network net;
net.addNeuron(0, 0.02, 0.20, -61.3, 6.5, -13.0, -65.0, 0.0);
net.addNeuron(1, 0.06, 0.23, -65.0, 2.0, -14.6, -65.0, 0.0);
\end{ccode}

To create a neuron the user specifies a unique index
	(which can be used when adding connections)
	as well as the neuron parameters (Section~\ref{model:neuron}).

Synapses can be added by specifying the source and target neurons as well as
	the weight, conductance delay (in milliseconds), and a plasticity flag.
For example, to connect the two above neurons in a recurrent fashion
	with one excitatory synapse and one inhibitory synapse one could do something like:

\begin{ccode}
net.addSynapse(0, 1, 10, 1.0, true);
net.addSynapse(1, 0, 1, -0.5, false);
\end{ccode}

This simple network is sufficient for illustrating the usage of the library. 

\subsection{Creating a configuration}

The configuration object specifies simulation-wide parameters, 
	such as a global STDP function (disabled by default).
It also specifies which of the available backends (Section~\ref{backends}) will be used. 
In many cases a default configuration can be used.

\begin{ccode}
nemo::Configuration conf;
\end{ccode}

A default-constructed configuration object will choose the best backend,
	but if a specific backend is desired the user can set this explicitly:

\begin{ccode}
conf.setCudaBackend();
\end{ccode}

or

\begin{ccode}
conf.setCpuBackend();
\end{ccode}

\subsection{Creating and running a simulation}

We can now create a simulation object from the network and configuration objects.

\begin{ccode}
nemo::Simulation* sim = simulation(net, conf); 
\end{ccode}

We can then run the simulation by stepping through it one millisecond at a time,
getting back a vector of fired neuron indices for each call:

\begin{ccode}
for(unsigned ms=0; ms < 1000; ++ms) {
	const std::vector<unsigned>& fired = sim->step();
}
\end{ccode}

We can also provide external stimulus to the network, by forcing specific neurons to fire.
For example, to force neuron 0 and 1 to fire synchronized at a steady 10Hz for 10 seconds
	one could do the following (ignoring firing output for the time being):

\begin{ccode}
std::vector<unsigned> stimulus;
stimulus.push_back(0);
stimulus.push_back(1);
for(unsigned ms=0; ms < 10000; ++ms) {
	if(ms % 100 == 0) {
		sim->step(stimulus);
	} else {
		sim->step();
	}
}
\end{ccode}

The above shows the basic usage of the simulator.
The user can perform other actions on the simulation object as well
	including querying synapse data,
	and use STDP.

For full details of library usage refer to the
	language-specific notes (Section~\ref{api})
	and the full function reference (Section~\ref{fnref}).

\section{Simulation model}
\label{model}

\subsection{Neuron model}
\label{model:neuron}

Neurons are based on the Izhikevich neuron model \cite{izhikevich2003simple_model}.
The model consists of a two-dimensional system of ordinary differential equations defined by
\begin{align}
	\dot{v} & = 0.04v^2+5v+140-u+I    \label{eq:update_v} \\
	\dot{u} & = a(bv-u)               \label{eq:update_u}
\end{align}
with an after-spike resetting
\begin{equation}
\label{eq:reset}
\text{if }v\ge30\text{ mV, then}\begin{cases}v\leftarrow c\\u\leftarrow u+d\end{cases}
\end{equation}

where $v$ represents the membrane potential
	and $u$ the membrane recovery variable,
	accounting for the activation of K$^+$
	and the inactivation of Na$^+$ 
	providing post-potential negative feedback to $v$.
	% and $' = d/dt$ where $t$ is time. 
The parameter $a$ describes the time scale of the recovery variable, 
	$b$ describes its sensitivity to sub-threshold fluctuations, 
	$c$ gives the after-spike reset value of the membrane potential, 
	and $d$ describes the after-spike reset of the recovery variable. 
The variables $a$--$d$ can be set so as to reproduce the behaviour of different types of neurons.
%Typically these values are randomised around some default values,
%	such as $a=0.02$, $b=0.2$, $c=-65$, and $d=2$.
The term $I$ in Equation~\ref{eq:update_v} represents the combined 
	current from spike arrivals from all presynaptic neurons,
	which are summed every simulation cycle.

In addition to the basic model parameters $a$--$d$ and state variables $u$ and $v$,
	the user can specify a random input current to each neuron. 
The input current is drawn from $\mathcal{N}(0, \sigma)$,
	where $\sigma$ is set separately for each neuron.
If $\sigma$ is set to zero, no input current is generated.


\subsection{Basic synapse model}
\label{model:synapse}

Synapses are specified by a conductance delay and a weight.
Conductance delays are specified in whole milliseconds, 
	with a minimum delay of 1 ms
	and the maximum supported delay is to 64 ms.

Synapses can be either static or plastic,
	using spike-timing synaptic plasticity,
	the details of which can be found in the next section.

\subsection{STDP model}
\label{model:stdp}

\nemo\ supports spike-timing dependant plasticity,
	i.e. synapses can change during simulation depending on the temporal relationship 
between the firing of the pre- and post-synaptic neurons. 
To make use of STDP the user must enable STDP globally by specifying an STDP function
	and enable plasticity for each synapse as appropriate when constructing the network.
A single STDP function is applied to the whole network.

Synapses can be either potentiated or depressed.
With STDP enabled,
	the simulation accumulates a weight change
	which is the sum of potentiation and depression for each synapse. 
Potentiation always moves the synaptic weight away from zero,
	which for excitatory synapses is more positive,
	and for inhibitory synapses is more negative.
Depression always moves the synapses weight towards zero.
The accumulation of potentiation and depression statistics takes place every cycle,
	but the modification of the weight only takes place when explicitly requested.

Generally a synapse is potentiated if a spike arrives shortly before the postsynaptic neuron fires. 
Conversely, if a spike arrives shortly after the postsynaptic firing the synapse is depressed. 
Also, the effect of either potentiation or depression generally weakens as the time difference, $dt$, 
	between spike arrival and firing increases. 
Beyond certain values of $dt$ before or after the firing, STDP has no effect. 
These limits for $dt$ specify the size of the STDP window.

The user can specify the following aspects of the STDP function:

\begin{itemize}
	\item the size of the STDP window;
	\item what values of $dt$ cause potentiation and which cause depression;
	\item the strength of either potentiation or depression for each value of $dt$, 
		i.e. the shape of the discretized STDP function;
	\item maximum weight of plastic excitatory synapses; and
	\item minimum weight of plastic inhibitory synapses.
\end{itemize}

Since the simulation is discrete-time,
	the STDP function can be specified by providing values of the underlying function
	sampled at integer values of $dt$.
For any value of $dt$ a positive value of the function denotes potentiation, 
	while a negative value denotes depression.
The STDP function is described using two vectors: 
	one for spike arrivals \emph{before} the postsynaptic firing (pre-post pair),
	and one for spike arrivals \emph{after} the postsynaptic firing (post-pre pair).
The total length of these two vectors is the size of the STDP window.
The typical scheme is to have positive values for pre-post pairs and negative values for post-pre pairs,
but other schemes can be used.

When accumulating statistics a pairwise nearest-neighbour protocol is used.
For each postsynaptic firing potentiation and depression statistics are updated based
on the nearest pre-post spike pair (if any inside STDP window) 
and the nearest post-pre spike pair (if any inside the STDP window).

Excitatory synapses are never potentiated beyond the user-specified maximum weight,
and are never depressed below zero.
Likewise, inhibitory synapses are never potentiated beyond the  user-specified minimum weight,
and are never depressed above zero.
Synapses can thus be deactivated, but never change from excitatory to inhibitory or vice versa.

% TODO: max size of window


%As a practical example, consider an asymmetric STDP scheme specified using the following functions for LTP and LTD:
%\[ stdp(dt) = \alpha e^{-dt / \tau} \]
%where $\alpha$ specifies a scaling and $\tau$ the size of either the potentiation or depression window. For LTP, let $\alpha = 1.0, \tau=20$, and for LTD let $alpha=0.8, \tau=20$. This STDP function is specified using two vectors like this:

\subsection{Discrete-time simulation}
\label{model:step}

The simulation is discrete-time with a fixed one millisecond step size.
Within each step the following actions take place in a fixed order:

\begin{enumerate}
	\item Compute accumulated current for incoming spikes;
	\item Update the neuron state;
	\item Determine if any neurons fired. The user can specify neurons which should be forced to fire at this point;
	\item Update the state of the fired neurons
	\item Accumulate STDP statistics, if STDP is enabled
\end{enumerate}

\subsection{Neuron and synapse indices}

The user specifies the unique index of each neuron.
These are just regular unsigned integers.
The neuron indices does not \emph{have} to start from zero and lie in a contiguous range, 
	but in the current implementation such a simple indexing scheme may lead to better memory usage.

Synapses also have unique indices, but these are assigned by the library itself.
% TODO: add reference to function here
Synapse indices are only required if querying the synapse state at run-time.

\subsection{Numerical precision}

The state update step uses the Euler method with a step size of 0.25ms. 

The weights are stored internally in a fixed-point format (Q11.20) for two reasons.
First,
	it is then possible to get repeatable results regardless of the order in which synapses are processed in a parallel setting (fixed-point addition is associative, unlike floating point addition).
Second, 
	it results in better performance,
		at least on the CUDA backend with older cards,
		where atomic operations are available for integer/fixed-point but not for floating point. 
The fixed-point format should not overflow for synapses with remotely plausible weights,
	but the current accumulation uses saturating arithmetic nonetheless.

Neuron parameters are stored as single-precision floating point.

% TODO: add this section back
%\section{Simulator backends}
%\label{backends}

%\subsection{CUDA}

% minimum device capability
% Fermi etc.
% Run-time dependencies

% Dynamic loading

%\subsection{CPU}

% 
% Run-time dependencies

\section{Application programming interface}
\label{api}

\nemo\ is implemented as a \cpp\ class library and can thus be used directly in programs written in \cpp.
There are also bindings in
	C (\ref{api:c}),
	Python (\ref{api:python}),
	and Matlab (\ref{api:matlab}).
The different language APIs follow largely the same programming model.
The following sections specify the language-specific issues
	(linking, naming schemes, etc)
	while a full function reference, applying to all language interfaces can be found in Section~\ref{fnref}.

\newpage

\subsection{C++ API}
\label{api:cpp}

The \cpp\ API is used by including the header file \file{nemo.hpp}
and linking against the nemo dynamic library (\file{libnemo.so} or \file{nemo.dll}).

All classes and functions are found in the \code{nemo} namespace.
Class names use initial upper-case. 
Function names use camelCase with initial lower-case letter.

The library is not thread safe.

Errors are reported via exceptions of type \code{nemo::exception}.
These are subclasses of \code{std::exception},
	so a descriptive error messages is availble using \code{const char* nemo::exception::what()}.
Additionally, 
	internally generated exceptions also carry an error number
	(\code{int nemo::exception::errorNumber()})
	which are listed in \code{<nemo/types.hpp>}.
If disambiguation between different \nemo-generated error types is not required,
	it is sufficient to simply catch \code{std::exception\&}.

The following code snippet shows basic usage.
The \nemo\ distribution contains an example directory with more advanced examples.

\begin{ccode}
#include <nemo.hpp>

...

try {
	nemo::Network net;
	net.addNeuron(0,0.02,0.20,-61.3,6.5,-13.0,-65.0,0.0);
	net.addNeuron(1,0.06,0.23,-65.0,2.0,-14.6,-65.0,0.0);
	net.addSynapse(0, 1, 10, 1.0, true);
	net.addSynapse(1, 0, 1, -0.5, false);

	nemo::Configuration conf;

	boost::scoped_ptr<nemo::Simulation>
		sim(nemo::simulation(net, conf)); 

	for(unsigned ms=0; ms < 1000; ++ms) {
		const vector<unsigned>& fired = sim->step();
		for(vector<unsigned>::const_iterator n = fired.begin();
				n != fired.end(); ++n) {
			cout << ms << " " << *n << endl;
		}
	}

} catch(exception& e) {
	cerr << e.what() << endl;
}

\end{ccode}

\newpage

\subsection{C API}
\label{api:c}

The C API follows the general object-model as outlined above.

To use the C API, include the header file \file{nemo.h} instead of \file{nemo.hpp},
	and then link to libnemo.

All names use lower case and are separated by underscores. 
Both function and type names are prefixed `\code{nemo\_}`
	and type names are also suffixed `\code{\_t}`.

In the C API the network, configuration, and simulation objects are controlled via opaque pointers
	with typedefed names \code{nemo\_network\_t}, \code{nemo\_configuration\_t}, and \code{nemo\_simulation\_t}.
These objects are generated with methods 
	\code{nemo\_new\_x} (\code{x} $=$ \code{network}, \code{configuration}, or \code{simulation}),
	and should be explicitly destroyed with the corresponding methods 
	\code{nemo\_delete\_x}.

Methods on specific objects take the relevant opaque pointer as the first parameter.

Error handling is done via return codes.
All API functions return a value of type \code{nemo\_status\_t},
	which will be \code{NEMO\_OK} if everything went fine and some other value (see \file{<nemo/types.h>}) otherwise.

The C API is not thread-safe.

The following C program program snippet shows basic usage of the \nemo\ library (without any error
handling): 

\begin{ccode}
#include <nemo.h>

...

nemo_network_t net = nemo_new_network();
nemo_add_neuron(net,0,0.02,0.20,-61.3,6.5,-13.0,-65.0,0.0);
nemo_add_neuron(net,1,0.06,0.23,-65.0,2.0,-14.6,-65.0,0.0);
nemo_add_synapse(net, 0, 1, 10, 1.0, true);
nemo_add_synapse(net, 1, 0, 1, -0.5, false);

nemo_configuration_t conf = nemo_new_configuration();
nemo_simulation_t sim = nemo_new_simulation(net, conf);

for(unsigned ms=0; ms < 1000; ms++) {
	unsigned *fired, nfired;
	nemo_step(sim, NULL, 0, NULL, NULL, 0, &fired, &nfired);
	for(unsigned i=0; i < nfired; i++) {
		printf("%u %u\n", ms, nfired[i]);
	}
}

nemo_delete_simulation(sim);	
nemo_delete_configuration(conf);
nemo_delete_network(net);
\end{ccode}

Note that the step function has arguments for providing firing stimulus and
input current stimulus, but that these are unused here.

\newpage

\subsection{Python API}
\label{api:python}

% Overview
The Python API for \nemo\ provides an object-oriented interface
	that closely reflects the underlying \cpp\ class library.
The module \library{nemo} contains the three objects
	\code{Network},
	\code{Configuration}, and
	\code{Simulation}.
The interface layer is implemented using \library{boost::python},
	the support library of which is statically linked in.
Function names are all \code{lower\_case\_with\_underscores}.

\paragraph{Setup}
To use the API, the installation path of the module \library{nemo} must be on the Python path.
The default paths are found in Table~\ref{tab:python-path}.
The Python path can be set by 
	setting the environment variable \command{PYTHONPATH},
	or within a script/session by calling \code{sys.path.add}.
One the module is on the path,
	it can be brought into scope by \code{import nemo}.

\begin{table}[!hb]
	\centering
	\begin{tabular}{ll}
		Platform & Default installation path \\
		\hline
		Windows & \file{C:\textbackslash Program Files\textbackslash NeMo\textbackslash Python} \\
		Linux & \file{/usr/share/nemo/python} \\
		\hline
	\end{tabular}
	\caption{Default Python API installation path.}
	\label{tab:python-path}
\end{table}

\paragraph{PyNN}
Python users may be interested in using the PyNN interface to \nemo.
PyNN is a common API for a number of spiking neural network simulators 
	including NEURON, NEST, PCSIM and Brian.
% TODO: add references
This interface provides more complex connection patterns,
	and more refined control of neuron popluations
	than the low-level API used by \nemo.
PyNN operates with a number of standard neuron models.
\nemo\ currently only supports the Izhikevich model.
To use PyNN, ensure the \library{nemo} module is installed and on the python path,
	and then do \code{from pyNN.nemo import *}.
PyNN is a separate larger project, which is fully documented elsewhere.

\paragraph{Help}
The classes and functions in the \library{nemo} module are documented using standard docstrings,
	so a full function reference is available from within an interactive session. 

\paragraph{Error handling}
Errors generated by \nemo\ result in a \code{RuntimeError} in the Python layer.

\paragraph{Usage example}
The general pattern of usage is

\begin{enumerate}
	\item create a configuration object and configurate as appropriate;
	\item create a network object and populate with neurons and synapses; and
	\item create a simulation from the configuration and network objects and run the simulation
\end{enumerate}

The following code shows a simple example
    constructing a network of 1000 fully connected neurons,
    simulating it for one second, and
    printing the indices of the fired neurons.

\lstinputlisting{example.py}

Note that the construction methods
    \code{Network.add\_neuron} and
    \code{Network.add\_synapse}
    supports an arbitrary mix of scalar and list arguments.
Other methods, such as neuron getters and setters support the same type of arguments.

\newpage

\subsection{Matlab API}
\label{api:matlab}

% Modal API
The Matlab API provides a modal functional interface,
	rather than the object-oriented interface of the underlying C++ library.
The user manipulates a single network and a single simulation,
	and is either in the construction/configuration mode or in the simulation mode.
Functions use camelCased identifiers, and are prefixed with `\code{nemo}'.

% Construction mode
During construction/configuration the user can
	set global configuration parameters,
	add or modify neurons, and
	add or modify synapses.
There is a single implicit network,
	which can be cleared by calling \code{nemoClearNetwork}.
The global configuration can be reset to defaults by calling \code{nemoResetConfiguration}.

% Simulation mode
Simulation mode is entered by calling \code{nemoCreateSimulation}.
During simulation mode the user can
	step through the simulation, providing stimulus as appropriate,
	read or modify the neuron state, and
	read the synapse state.
When a simulation is complete, configuration/construction mode is entered again
	by calling \code{nemoDestroySimulation}.
Note that after destroying the simulation,
	the network is in the same state as before the simulation was started.

Help is available for each function using Matlab's regular help system,
	i.e. via calls such as
		\code{help nemoAddNeuron}
		and \code{help nemoStep}.
A top-level help entry is available under \code{help nemo},
	which gives a brief overview and lists the available functions.

Internal \nemo\ errors result in regular Matlab errors,
	(i.e. as when \code{error} is called in a script).
These errors use identifier
	\code{nemo:api} for basic usage errors for input and output arguments,
	\code{nemo:backend} for errors within the \nemo\ library itself, and
	\code{nemo:mex} for internal errors in the MEX layer.

The Matlab path must contain the directory with the m-files
	defining the available functions and the MEX library that interfaces with libnemo
	(Table~\ref{tab:matlab-path}.
Use \code{addpath} from within Matlab to set this path.

\begin{table}[!hb]
	\centering
	\begin{tabular}{ll}
		Platform & Default installation path \\
		\hline
		Windows & \file{C:\textbackslash Program Files\textbackslash NeMo\textbackslash Matlab} \\
		Linux & \file{/usr/share/nemo/matlab} \\
		\hline
	\end{tabular}
	\caption{Default Matlab API installation path.}
	\label{tab:matlab-path}
\end{table}

Additionally, the \nemo\ libraries (plus any dependencies such as possibly the CUDA runtime library)
	needs to be on the system path.
Note that this is different from the Matlab path.
If the system path is not set correctly Matlab will issue a rather unhelpful message about the MEX-file being invalid.

Note that on Linux Matlab does its own loading of \cpp\ standard libraries
	(to use the version used when Matlab was built).
Unless the stars are aligned just so this standard library version will be
different from the default \cpp\ standard libraries on the system (which \nemo\ should have been built against), resulting in an error when loading the MEX file.
This can be fixed by setting \code{LD\_PRELOAD} by doing something like this

\begin{shell}
export LD_PRELOAD=/lib/libgcc_s.so.1:/usr/lib/libstdc++.so.6.0.13
\end{shell}

before starting Matlab.

The following shows a simple Matlab session using \nemo\ to set up a network of
1000 fully connected neurons, simulate this network for one second, and print
the firing pattern:

\lstinputlisting{example.m}

\newpage
\section{Function reference}
\label{fnref}

\input{fnref}

\section{Installation}

\subsection{Windows}
\label{installation:windows}

The easiest way to install is by using the precompiled library (NSIS installer).
This installs \nemo\ to \directory{C:\textbackslash Program Files\textbackslash NeMo},
	with
		libraries in the \directory{bin} subdirectory and
		headers in the \directory{include} subdirectory,
Python bindings, Matlab bindings, and examples are stored in separate subdirectories.

Alternatively, the library can be built from source using \command{cmake} to generate a Visual Studio project file,
	and then building from within Visual Studio (see Section~\ref{source_build}).
Builds in Cygwin or MSys/MinGW have not been tested.

\subsection{Linux}

There are no precompiled binaries for linux,
	so the library should be built from source using \command{cmake}.
By default,
	headers are installed to \file{/usr/local/include},
	the library files to \file{/usr/local/lib},
	Python bindings, Matlab bindings, examples and documentation to subdirectories of \directory{/usr/local/share/nemo}.

\subsection{OSX}

The easiest way to install is by using the precompiled library (PackageMaker installer).
By default,
	headers are installed to \directory{/usr/include},
	library files are installed to \directory{/usr/lib},
	while
	Python bindings, Matlab bindings, examples and documentation are found in subdirectories of \directory{/usr/share/nemo}.
Alternatively, the library can be built from source using \command{cmake} and the GNU build tools (see Section~\ref{source_build}).

\subsection{Building from source}
\label{source_build}

\nemo\ relies on the boost headers.
Additionally the following dependencies may be needed depending on what \command{cmake} configuration options are set: 

\begin{tabular}{p{.3\textwidth}lp{.3\textwidth}}
\hline
Feature & \command{cmake} option & Dependency \\
\hline
CUDA backend & \command{NEMO\_CUDA\_ENABLED} & Cuda toolkit \\
\hspace{2em}dynamic loading & \command{NEMO\_CUDA\_DYNAMIC\_LOADING} & \command{libltdl} (Linux/OSX) \\
Timing functions & \command{NEMO\_TIMING\_ENABLED} & boost date\_time \\
Python bindings & \command{NEMO\_PYTHON\_ENABLED} & boost python \\
Matlab bindings & \command{NEMO\_MATLAB\_ENABLED} & Matlab (including \command{mex} compiler) \\
Example programs & \command{NEMO\_EXAMPLES\_ENABLED} & boost program\_options \\ 
\hline
\end{tabular}

% Additionally the CUDA toolkit should be installed, if simulation on GPUs is desired. 

The basic \command{cmake} build procedure is 

% TODO: use code environment
\begin{shell}
cd <nemo-directory>
mkdir build
cd build
cmake ..
make
sudo make install
\end{shell}

% TODO:
% add section on common build issues.
% LTDL variables not set: install libltdl or disable DYNAMIC LOADING.




% \subsection{General dependencies}

% Dependencies
%	\item CUDA toolkit $\geq$ 2.1. The SDK is not required.
%	\item Boost
%	\item CMake $\geq$ 2.8

%Note that the CUDA compiler driver \command{nvcc} is not compatible with all versions
%of \command{gcc}, especially newer versions of \command{gcc}.

%For Boost, mostly header-only libraries are required (\library{shared\_ptr}, \library{tuples},
%\library{random}, \library{date\_time}), so a full install/build is generally not required. 
%Note, however, that some versions of Visual \cpp\ require \library{date\_time} to be compiled as
%a proper library. 
%The \library{date\_time} library is only required for simulation timing,
%	and can be disabled in the cmake configuration stage via the \code{INCLUDE\_TIMING\_API} variable.

% \section{Linux/Unix installation}


\bibliographystyle{abbrv}
\bibliography{manual}

\end{document}
