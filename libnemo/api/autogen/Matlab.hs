module Matlab (generate, synopsis, ctorSynopsis) where

import Control.Monad (zipWithM, zipWithM_, when, liftM)
import Data.Char (toUpper, toLower, isUpper)
import Data.List (intercalate)
import Data.Maybe (catMaybes)
import Data.String.Utils
import Text.Printf
import Text.PrettyPrint
import System.IO

import API
import Codegen
import qualified Common


-- TODO: move this into language-specific
comment :: Language -> Code -> Code
comment Matlab str = "% " ++ str
comment CPP str = "/* " ++ str ++ " */"

autoComment :: Language -> Code
autoComment lang = nl $ nl $ comment lang $ "auto-generated by API.hs"

statement :: Code -> Code
statement code = code ++ ";\n"

{- The matlab API consists of:
 - 1. A MEX file which wraps calls to underlying C++ objects
 - 2. A number of m-files which calls the m-file and includes
 -    function documentation -}
generate :: [ApiModule] -> IO ()
generate ms = do
    mex <- openFile "../matlab/nemo_mex.cpp" WriteMode
    insertFileContents mex "../matlab/sources/nemo.header.mex"
    hPutStr mex $ nl $ nl $ comment CPP $ "AUTO-GENERATED CODE START"
    -- two ids per module for constructor and destructor
    let startId = scanl (+) 0 $ map (+2) $ map (length . mdl_functions) ms
    ftable <- zipWithM (classdef mex) startId ms
    mexFunctionTable mex $ concat ftable
    hPutStr mex $ nl $ nl $ comment CPP $ "AUTO-GENERATED CODE END"
    insertFileContents mex "../matlab/sources/nemo.footer.mex"
    hClose mex


{- Write all function defintions in a module to both MEX file and M-file.
 - Return all the function names used by MEX -}
classdef :: Handle -> Int -> ApiModule -> IO [String]
classdef mex start_id mdl = do
    let mname = mdl_name mdl
        className = "nemo" ++ mname
    -- TODO: use filepath here
    withFile ("../matlab/" ++ className ++ ".m") WriteMode $ \mclass -> do
    -- write the module documentation
    hPutStr mclass $ render $ classHelp mdl className
    classHeader mclass mname className start_id (start_id+1)
    fn_names <- zipWithM (go mdl mclass) (mdl_functions mdl) [start_id+2..]
    hPutStr mclass $ end 1 -- end methods
    hPutStr mclass $ end 0 -- end class
    return $! ("new" ++ mname) : ("delete" ++ mname) : fn_names
    where
        -- Write function definition to both MEX and M-file. Return the index/function name pair.
        go :: ApiModule -> Handle -> ApiFunction -> Int -> IO String
        go mdl mclass fn fn_id = do
            memberFunction mclass fn fn_id
            mexFunctionC mex (mdl_name mdl) fn
            -- mexFunction mex (mdl_name mdl) fn
            return $! mexFunctionName fn



classHeader :: Handle -> String -> String -> Int -> Int -> IO ()
classHeader mclass mdlName className ctorId dtorId = do
    -- TODO: put a list of method
    hPutStr mclass $ nl $ nl $ printf "classdef %s < handle" className
    hPutStr mclass $ nl $ indent 1 $ "properties"
    hPutStr mclass $ indent 2 $ statement $ "% the MEX layer keeps track of the actual pointers"
    hPutStr mclass $ indent 2 $ statement $ assign "id" "-1"
    hPutStr mclass $ nl $ end 1
    hPutStr mclass $ nl $ nl $ indent 1 "methods"

    -- ctor is hand-written
    includeFunction mclass ("new" ++ mdlName) ctorId
    -- TODO: tidy
    -- ctorDef <- readFile $ "matlab/new" ++ mdlName ++ ".in.m"
    -- hPutStr mclass $ nl $ unlines $ map (indent 2) $ lines $ replace "FNID" (show ctorId) ctorDef

    -- destructor
    hPutStr mclass $ nl $ indent 2 $ "function delete(obj)"
    -- TODO: how do we get the function ID here?
    hPutStr mclass $ indent 3 $ statement $ printf "nemo_mex(uint32(%u), obj.id)" $ dtorId
    hPutStr mclass $ end 2


classHelp :: ApiModule -> String -> Doc
classHelp m mname = (commentBlock2 0 $ vcat [
            text mname, space,
            descr, space,
            text "Methods:",
            methods, space
        ]) <+> (char '\n')
    where
        descr = fsep $ maybe [] (map text . words) $ mdl_descr m
        methods = nest 4 $ vcat $ (:) ctor $ map (text . fn_name) $ mdl_functions m
        ctor = text mname <+> (parens $ text "constructor")

end :: Int -> Code
end ntabs = nl $ render $ nest (4*ntabs) $ text "end"



{- Insert matlab function into class file. This simply calls the MEX file,
 - while marshalling arguments as appropriate. The M-file help is prepended to
 - the function -}
memberFunction :: Handle -> ApiFunction -> Int -> IO ()
memberFunction mfile fn idx = do
    if Matlab `elem` fn_noauto fn
        then do
            putStrLn $ "Using hand-written version of " ++ (fn_name fn)
            includeFunction mfile (fn_name fn) idx
        -- else if fn_vectorized fn
          --  then vectorizedMemberFunction mfile fn idx
        else memberFunction_auto mfile fn idx


memberFunction_auto :: Handle -> ApiFunction -> Int -> IO ()
memberFunction_auto mfile fn fn_id = do
    putStrLn $ "Generating " ++ (fn_name fn)
    let fnname = name fn
    hPutStr mfile $ nl ""
    let arg0 = text $ printf "uint32(%u)" fn_id
        userArgs = map (text . matlabInput . arg) $ fn_inputs fn
    hPutStr mfile $ render $ nest 8 $ matlabClassMethodHeader fn
    hPutStr mfile "\n"
    -- TODO: use pretty-printing here instead throughout
    -- TODO: return Doc from matlabHelp.
    hPutStr mfile $ render $ matlabHelp fn fnname
    -- TODO: add handling of optional arguments here:
    --      - add optionals based on nargs which sets the arguments
    hPutStr mfile $ render $ nest 12 $
        matlabFunctionCall (text "nemo_mex") (matlabFunctionReturn $ fn_output fn) (arg0: (text "obj.id") : userArgs)
    hPutStr mfile ";\n"
    hPutStr mfile $ end 2


{- Some functions in the Matlab API are vectorised. The normal form of the
 - function in the C++ interface should have all scalar arguments. The
 - generated Matlab function accepts vector input (with vectors of the same
 - length) and internally calls the scalar version -}
{-
vectorizedMemberFunction :: Handle -> ApiFunction -> Int -> IO ()
vectorizedMemberFunction mfile fn idx = do
    putStrLn $ "Generating " ++ (fn_name fn)
    hPutStr mfile ( )
    where
        fname = fn_name fn
        fdef :: Doc
        fdef =
            -- void return and fixed function header 
-}



{- Some mfiles are hand-written due to special constraints on input or output
 - format. These are simply included with the function index substituted as
 - appropriate -}
includeFunction :: Handle -> String -> Int -> IO ()
includeFunction mfile basename fnIdx = do
    fnDef <- readFile $ "../matlab/sources/" ++ basename ++ ".in.m"
    hPutStr mfile $ nl $ unlines $ map (indent 2) $ lines $ replace "FNID" (show fnIdx) fnDef


commentBlock :: Int -> String -> Doc
commentBlock i str = nest i $ vcat $ map commentLine $ map text $ lines $ render $ fsep $ map text $ words str


commentBlock2 :: Int -> Doc -> Doc
commentBlock2 i doc = nest i $ vcat $ map (commentLine . text) $ lines $ render doc
-- commentBlock2 i str = nest i $ vcat $ map commentLine $ map text $ lines $ render $ fsep $ map text $ words str

commentLine :: Doc -> Doc
commentLine = (<+>) $ char '%'

description :: Doc -> Maybe Doc -> Doc
-- TODO: deal with long lines here
description term defn = term <+> (maybe empty ((char '-') <+>) defn)
-- description term defn = hang term 4 $ maybe empty ((char '-') <+>) defn


matlabArgDescription :: (Named a, Described a) => a -> Doc
matlabArgDescription x = h $$ nest indent t
    where
        n = name x
        indent = 10
        nspace = max 1 $ indent - length n - 2
        h = hcat $ [text n] ++ (replicate nspace space) ++ [char '-']
        t = maybe empty (fsep . map text . words) $ describe x



matlabHelp :: ApiFunction -> String -> Doc
matlabHelp fn fnname = (commentBlock2 8 $ vcat $ [
            header, space,
            synopsis, space,
            inputs,
            outputs,
            descr]) <+> (char '\n')
    where
        header =  description (text fnname) (Just $ text $ fn_brief fn)

        synopsisCall = matlabFunctionCall (text fnname)
                (matlabFunctionReturn $ fn_output fn) $ map (text . name) $ fn_inputs fn

        synopsis = ($+$) (text "Synopsis:") $ nest 2 synopsisCall

        optlist :: (Named a, Described a) => String -> [a] -> Doc
        optlist title xs =
            if null xs
                then empty
                else hang (text title <> char ':') 2 $ vcat $ (map matlabArgDescription xs) ++ [space]

        inputs = optlist "Inputs" $ fn_inputs fn
        outputs = optlist "Outputs" $ fn_output fn

        descr = maybe empty (fsep . map text . words) $ fn_descr fn


-- TODO: make use of this in matlabHelp
synopsis :: ApiModule -> ApiFunction -> Doc
synopsis mdl fn = matlabFunctionCall fnname (matlabFunctionReturn $ fn_output fn) $ map (text . name) $ fn_inputs fn
    where
        obj = text $ mdl_sname mdl
        method = text $ name fn
        fnname = memberCall obj method


ctorSynopsis :: ApiModule -> Doc
-- ctorSynopsis mdl = sname <+> char '=' <+> cname
ctorSynopsis mdl = Common.functionCall Common.None cname (Just sname) 60 args
    where
        sname = text $ mdl_sname mdl
        cname = text $ "nemo" ++ mdl_name mdl
        args  = map (text . mdl_sname) $ constructorArgs $ mdl_ctor mdl


memberCall :: Doc -> Doc -> Doc
memberCall obj method = obj <> char '.' <> method

-- TODO: remove
{- To conform with the usual Matlab style, print input and output arguments in upper-case -}
matlabArgname :: String -> String
matlabArgname = id -- map toUpper



uncamel [] = []
uncamel (x:xs)
    | isUpper x = '_' : toLower x : uncamel xs
    | otherwise = x : uncamel xs



mexFunctionName :: ApiFunction -> String
mexFunctionName = fn_name


cFunctionName :: ApiFunction -> String
cFunctionName = prefix "nemo_" . uncamel . fn_name
    where
        -- TODO: move to Codegen
        prefix pf str = pf ++ str


-- | All MEX functions have the same header
mexFunctionDefinition :: ApiFunction -> Doc -> Doc
mexFunctionDefinition fn body = functionDefinition ret name args body
    where
        ret = text "void"
        name = text $ fn_name fn
        args = map text ["int nlhs", "mxArray* plhs[]", "int nrhs", "const mxArray* prhs[]"]


-- TODO: add function mapping type to string
functionDefinition :: Doc -> Doc -> [Doc] -> Doc -> Doc
functionDefinition ret name args body = vcat [ret, proto, lbrace, nest 4 body, rbrace, nl, nl, nl]
    where
        -- TODO: do this like in arglist, with possible hanging
        proto = (<>) name $ parens $ hcat $ punctuate (text ", ") args
        nl = text ""


functionCall
    :: Doc          -- text to indicate multiline continuation
    -> Doc          -- function name
    -> Maybe Doc    -- output assignment
    -> [Doc]        -- arguments
    -> Doc
functionCall cont name output inputs = assign <> call
    where
        assign = maybe empty (<+> (text "= ")) output
        call = if length args_oneline > 60
                then vcat $ [name <> lparen <> cont] ++ args_multiline ++ [rparen]
                else (<>) name $ parens $ text args_oneline
        -- TODO: separate out multiline functionality
        args_oneline = render $ hcat $ punctuate (text ", ") inputs
        args_multiline = map (nest 8 . (<> cont)) $ punctuate (char ',') inputs

matlabFunctionCall = functionCall (text "...")
cFunctionCall = functionCall space


-- note: hard-coded self
matlabClassMethodHeader :: ApiFunction -> Doc
matlabClassMethodHeader fn = (text "function") <+> call
    where
        call = matlabFunctionCall fname (matlabFunctionReturn $ fn_output fn) inputs
        fname = text $ name fn
        inputs = (text "obj") : (map (text . name) $ fn_inputs fn)


{- Output arguments are assigned to separate output variables -}
matlabFunctionReturn :: [OutputType] -> Maybe Doc
matlabFunctionReturn []  = Nothing
matlabFunctionReturn [x] = Just $ text $ name x
matlabFunctionReturn xs  = Just $ Common.arglistWith brackets $ map (text . name) xs


-- TODO: remove original statement function
stmt :: Doc -> Doc
stmt x = x <> char ';'


declareInit :: Doc -> Doc -> Doc -> Doc
declareInit t lhs rhs = t <+> lhs <+> (char '=') <+> rhs


mexFunctionC :: Handle -> String -> ApiFunction -> IO ()
mexFunctionC mex mdl_name fn =
    when (MEX `notElem` fn_noauto fn) $ hPutStr mex $ render $ fdef mdl_name fn
    where
        fdef | fn_vectorized fn = mexVectorFunction
             | otherwise        = mexScalarFunction


mexScalarFunction :: String -> ApiFunction -> Doc
mexScalarFunction mdl_name fn = mexFunctionDefinition fn body
    where
        body = vcat $ [
                -- NOTE: input and output checks may be redundant
                stmt $ cFunctionCall (text "checkInputCount") Nothing [text "nrhs", int (length $ fn_inputs fn)],
                stmt $ cFunctionCall (text "checkOutputCount") Nothing [text "nlhs", int (length $ fn_output fn)],
                mexDeclareInputVariables 2 $ fn_inputs fn,
                mexDeclareOutputVariables $ fn_output fn,
                stmt $ cFunctionCall (text "checkNemoStatus") Nothing $
                        [cFunctionCall (text $ cFunctionName fn) Nothing (ptr : callArgs)],
                mexReturnOutputVariables $ fn_output fn
            ]
        ptr = cFunctionCall getHandle Nothing [text "prhs", int 1]
        getHandle = (text "get") <> (text mdl_name)
        -- TODO: here!!!
        -- expand outputArgs so that they contain both vector and length
        -- make sure they are reference types as well
        callArgs = inputArgs ++ outputArgs
        inputArgs = zipWith mexInput [2..] $ fn_inputs fn
        outputArgs = map mexOutput $ fn_output fn



mexVectorFunction :: String -> ApiFunction -> Doc
mexVectorFunction mdl_name fn = mexFunctionDefinition fn body
    -- TODO: get the handle argument only once to reduce overhead, esp. for error checking
    where
        body = vcat $ [
                {- In the vector form, all inputs should have the same format.
                 - A pre-defined function can verify this. -}
                stmt $ cFunctionCall (text "vectorDimension") (Just $ text "size_t elems") [int inputCount, text "prhs + 2"],
                stmt $ cFunctionCall (text "checkInputCount") Nothing [text "nrhs", int inputCount],
                stmt $ cFunctionCall (text "checkOutputCount") Nothing [text "nlhs", int outputCount],
                mexDeclareInputVariables 2 $ fn_inputs fn,
                mexAllocateVectorOutputs $ fn_output fn,
                -- mexDeclareOutputVariables $ fn_output fn,
                stmt $ cFunctionCall getHandle (Just (text "void* hdl")) [text "prhs", int 1],
                forLoop indexVar "0" "elems" loopBody
                -- mexReturnOutputVariables $ fn_output fn
            ]
        -- ptr = cFunctionCall getHandle Nothing [text "prhs", int 1]
        getHandle = (text "get") <> (text mdl_name)
        callArgs = inputArgs ++ outputArgs
        inputCount = length $ fn_inputs fn
        inputArgs = zipWith (mexVectorInput indexVar) [2..] $ fn_inputs fn
        outputCount = length $ fn_output fn
        outputArgs = map mexOutput $ fn_output fn
        indexVar = "i"
        loopBody = vcat $ [
                -- use a temporary scalar for the output
                mexDeclareOutputVariables $ fn_output fn,
                stmt $ cFunctionCall (text "checkNemoStatus") Nothing $ [cFunctionCall (text $ cFunctionName fn) Nothing (text "hdl" : callArgs)],
                -- then convert to Matlab format and return
                mexVectorizedReturn indexVar $ fn_output fn
            ]



{- Idiomatic for loop -}
forLoop
    :: String  -- ^ indexing variable
    -> String  -- ^ start
    -> String  -- ^ end
    -> Doc     -- ^ body of loop
    -> Doc
forLoop idx start end body = vcat [header, nest 4 body, char '}']
    where
        header = text $ printf "for(size_t %s=%s; %s<%s; ++%s){" idx start idx end idx



-- TODO: move to C.hs
addressOf :: Doc -> Doc
addressOf x = char '&' <> x


{- For vectors we need to pass a pointer and a length separately, so we need to
 - create the vector before the call. This also the cast from Matlab types if
 - required. In the MEX layer we don't deal with optional arguments. -}
mexDeclareInputVariables :: Int -> [Input] -> Doc
mexDeclareInputVariables _ [] = empty
mexDeclareInputVariables firstarg xs = vcat $ zipWith singleDecl [firstarg..] $ map arg xs
    where
        singleDecl :: Int -> ApiArg -> Doc
        singleDecl argno x =
            if scalar x
                then empty
                else stmt $ cFunctionCall (call x) (decl x) [text $ printf "prhs[%u]" argno]

        mtype = mexType . baseType . arg_type
        ntype = cppType . baseType . arg_type
        call x = text $ printf "vector<%s, %s>" (ntype x) (mtype x)
        decl x = Just $ text $ printf "std::vector<%s> %s" (ntype x) $ name x



{- Since we use the C interface, outputs are returned via pointers. Currently
 - we only auto-generate scalar returns -}
mexDeclareOutputVariables :: [OutputType] -> Doc
mexDeclareOutputVariables [] = empty
mexDeclareOutputVariables xs = vcat $ map singleDecl xs
    where
        singleDecl :: OutputType -> Doc
        singleDecl x = vcat [mainDecl x , vectorLen x]

        mainDecl x = (typeDecl $ arg_type x) <+> (text $ name x) <> char ';'

        vectorLen x = if scalar x then empty else (text $ "size_t " ++ name x ++ "_len;")

--            if scalar x
--                then (typeDecl $ arg_type x) <+> (text $ name x) <> char ';'
--                else (typeDecl $ arg_type x) <+> (text $ name x

        typeDecl :: Type -> Doc
        typeDecl (Scalar t) = text $ cppType t
        -- For vectors we need both an output pointer and the length
        typeDecl (Vector t _) = pointer t
        --  typeDecl (Vector t) = error "vector output not supported"


mexReturnOutputVariables :: [OutputType] -> Doc
mexReturnOutputVariables [] = empty
mexReturnOutputVariables xs = vcat $ zipWith go [0..] xs
    where
        go :: Int -> OutputType -> Doc
        -- go argno arg =
        --    let t = baseType $ arg_type arg
        --    in text $ printf "returnScalar<%s, %s>(plhs, %u, %s);" (cppType t) (mexType t) argno (name arg)
        -- go (Vector t) = printf "returnVector<%s, %s>(plhs, %s)" (cppType t) (mexType t) str
        go argno arg = text $
            if scalar arg
                then printf "returnScalar<%s, %s>(plhs, %u, %s);" (cppType t) (mexType t) argno (name arg)
                else printf "returnVector<%s, %s>(plhs, %u, %s, %s);" (cppType t) (mexType t) argno n (n ++ "_len")
            where
                t = baseType $ arg_type arg
                n = name arg



mexVectorizedReturn :: String -> [OutputType] -> Doc
mexVectorizedReturn _ [] = empty
mexVectorizedReturn idx xs = vcat $ zipWith go [0..] xs
    where
        go :: Int -> OutputType -> Doc
        go argno arg = text $
            if scalar arg
                then printf "returnScalarAt<%s, %s>(plhs, %u, %s, %s);" (cppType t) (mexType t) argno idx (name arg)
                else error "Vectorized function with non-scalar output in underlying API function"
            where
                t = baseType $ arg_type arg
                n = name arg



mexAllocateVectorOutputs :: [OutputType] -> Doc
mexAllocateVectorOutputs [] = empty
mexAllocateVectorOutputs xs = vcat $ zipWith go [0..] xs
    where
        go :: Int -> OutputType -> Doc
        go argno arg =
            if scalar arg
                then stmt $ cFunctionCall (text "allocateOutputVector" <> Common.angleBrackets (text $ mexType t)) Nothing [text "plhs", int argno, text "elems"]
                else error "Vectorized function with non-scalar output in underlying API function"
            where
                t = baseType $ arg_type arg


{- We use a single MEX file with a single exposed function. Dispatch to the
 - correct function is done via the first input argument. mexFuncionTable
 - prints the table of function pointers. -}
mexFunctionTable :: Handle -> [String] -> IO ()
mexFunctionTable mex ftable = do
    hPutStr mex $ nl $ statement $ "typedef void (*fn_ptr)(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])"
    hPutStr mex $ nl $ nl $ "#define FN_COUNT " ++ show (length ftable)
    hPutStr mex $ nl $ statement $ assign "fn_ptr fn_arr[FN_COUNT]" $ list 1 cbracket ftable



{- In the MEX layer we must use types that Matlab can work with -}
mexType :: BaseType -> String
mexType ApiFloat = "double"
mexType ApiUInt = "uint32_t"
mexType ApiInt = "int32_t"
mexType ApiUInt64 = "uint64_t"
mexType ApiULong = "uint64_t"
mexType ApiBool = "uint8_t"
mexType ApiString = "char*"


{- In the Matlab layer we need to translate from whatever random type the input
 - is (probably double) to a sensible format -}
cppType :: BaseType -> String
cppType ApiFloat = "float"
cppType ApiUInt = "unsigned"
cppType ApiUInt64 = "uint64_t"
cppType ApiInt = "int"
cppType ApiULong = "unsigned long"
cppType ApiBool = "unsigned char"
cppType ApiString = "const char*"


pointer :: BaseType -> Doc
pointer baseType = (text $ cppType baseType) <> char '*'


mexInput :: Int -> Input -> Doc
mexInput argno a = text $
    if scalar a
        then printf "scalar<%s,%s>(prhs[%d])" (cppType t) (mexType t) argno
        else if explicitLength (fullType a)
            then printf "&%s[0], %s.size()" n n
            -- TODO: add length check for implicit inputs
            else printf "&%s[0]" n
    where
        t = baseType a
        n = name a


{- Input argument for vectorized function. This is vectorized in the MEX layer,
 - i.e. the input is a Matlab matrix/vector and we access the C API for each
 - element. -}
mexVectorInput :: String -> Int -> Input -> Doc
mexVectorInput idx argno a = text $
    if scalar a
        then printf "scalarAt<%s,%s>(prhs[%d], %s)" (cppType t) (mexType t) argno idx
        else error "mexVectorInput called with input which is already a vector"
    where
        t = baseType a
        n = name a


mexOutput :: OutputType -> Doc
-- mexOutput = addressOf . text . name
mexOutput arg = text $
    if scalar arg
        then printf "&%s" n
        else if explicitLength (fullType arg)
            then printf "&%s, &%s_len" n n
            else printf "&%s" n
    where
        n = name arg


matlabType :: BaseType -> String
-- TODO: do the conversion on the matlab side instead
matlabType ApiFloat = "double" -- these are converted on the C side
matlabType ApiUInt = "uint32"
matlabType ApiUInt64 = "uint64"
matlabType ApiInt = "int32"
matlabType ApiULong = "uint64"
matlabType ApiBool = "uint8"


matlabInput :: ApiArg -> String
matlabInput arg = printf "%s(%s)" (matlabType $ baseType $ arg_type arg) (name arg)
