"""
The NeMo spiking neural network simulator
=========================================

NeMo is a fast spiking neural network simulator which can run on CUDA-enabled
GPUs. The ``nemo`` module provides an object-oriented interface to the C++
class library. The interface is based around three classes: Network,
Configuration, and Simulation.

Basic usage is as follows:

1. create a configuration;
2. create and populate a network by adding individual neurons and synapses; and
3. create a simulation from the configuration and network object, and run the
   simulation providing stimulus and reading outputs as appropriate

More details can be found in the documentation for each of these classes.

The following example shows how a small network of 1000 neurons is created and
simulated for one second::
    
    import nemo
    import random

    net = nemo.Network()
    iz = net.add_neuron_type('Izhikevich')

    # Excitatory neurons
    for nidx in range(800):
        r = random.random()**2
        c = -65.0+15*r
        d = 8.0 - 6.0*r
        net.add_neuron(iz, nidx, 0.02, 0.2, c, d, 5.0, 0.2*c, c);
        targets = range(1000)
        weights = [0.5*random.random() for tgt in targets]
        net.add_synapse(nidx, targets, 1, weights, False);

    # Inhibitory neurons
    for n in range(200):
        nidx = 800 + n
        r = random.random()
        a = 0.02+0.08*r
        b = 0.25-0.05*r
        c = -65.0
        net.add_neuron(iz, nidx, a, b, c, 2.0, 2.0, b*c, c)
        targets = range(1000)
        weights = [-random.random() for tgt in targets]
        net.add_synapse(nidx, targets, 1, weights, False);

    conf = nemo.Configuration()
    sim = nemo.Simulation(net, conf)
    for t in range(1000):
        fired = sim.step()
        print t, ":", fired

There is also a higher-level interface using the PyNN common simulator
interface.  PyNN is a large separate project which is documented in full
elsewhere.
"""

import sys
import warnings

sys.path.append('@CMAKE_INSTALL_PREFIX@/@INSTALL_DIR@')
from _nemo import *

init()


def step(self, fstim=None, istim=None):
    """
    run simulation for a single cycle (1ms)

    Inputs:
    fstim -- An optional list of neurons which will be forced to fire this cycle
    istim -- An optional list of neuron index/current pairs for external stimulus of the network
    """
    if fstim:
        if istim:
            return self.step_fi(fstim, istim)
        else:
            return self.step_f(fstim)
    else:
        if istim:
            return self.step_i(istim)
        else:
            return self.step_noinput()

Simulation.step = step


try:
    import numpy as np
    import array

    def to_vector_arg(x):
        """ Return a type readable as an optionally vectorised argument

        The NeMo vectorised functions accept either a scalar or a sequence
        type. A significant omission of this is numpy.ndarray, which is
        converted in this function. If the input is *not* an ndarray, we simply
        pass it through, which may result in errors from the boost::python
        layer if the type is not valid.
        """
        if type(x) == np.ndarray:
            # It seems that the numpy type codes and the array type codes match
            y = array.array(x.dtype.char)
            y.fromstring(x.data)
            return y
        else:
            return x

    def add_synapse(self, source, target, delay, weight, plastic):
        """ Add one or more synapses to the network
        
        Inputs:
        source -- Index of source neuron
        target -- Index of target neuron
        delay -- Synapse conductance delay in milliseconds
        weight -- Synapse weights
        plastic -- Boolean specifying whether or not this synapse is plastic
        
        Returns Unique synapse ID
        
        The input arguments can be any combination of scalars and vectors of
        equal length. Vector arguments can be any sequence type (including
        list) or a numpy.ndarray.  If the input arguments contain a mix of
        scalars and lists the scalar arguments are effectively replicated the
        required number of times.
        """
        return self.add_synapse_vec(
            to_vector_arg(source),
            to_vector_arg(target),
            to_vector_arg(delay),
            to_vector_arg(weight),
            plastic)

    Network.add_synapse = add_synapse

    def add_neuron(self, type, idx, *args):
        """ Add one or more neurons to the network
        
        Inputs:
        type -- Neuron type
        idx -- Neuron index
        *args -- all neuron parameters followed by all state variables
        
        The meaning of the parameters and state variables varies depending on the
        neuron type. This function may be called either in a scalar or vector
        form. In the scalar form all inputs are scalars. In the vector form,
        the neuron index argument plus any number of the other arguments are
        sequences (which could be lists) or numpy.ndarrays of the same length.
        In this second form scalar inputs are replicated the appropriate
        number of times
        """
        vargs = [to_vector_arg(x) for x in args]
        return self.add_neuron_vec(type, idx, *vargs)

    Network.add_neuron = add_neuron


except ImportError:
    print("Warning: failed to lead either 'numpy' or 'array'. numpy vector arguments not supported")
    Network.add_synapse = add_synapse_vec
    Network.add_neuron = add_neuron_vec



# Old synapse getters. These were originally vector-only, and were only exposed
# for the simulation class. The new getters support both vector and scalar
# forms, and use more consistent naming.

def deprecated(func):
    """This is a decorator which can be used to mark functions
    as deprecated. It will result in a warning being emitted
    when the function is used."""
    def new_func(*args, **kwargs):
        warnings.warn("Call to deprecated function %s." % func.__name__,
                      category=DeprecationWarning)
        return func(*args, **kwargs)
    new_func.__name__ = func.__name__
    new_func.__doc__ = func.__doc__
    new_func.__dict__.update(func.__dict__)
    return new_func

@deprecated
def get_targets(self, ids):
    return self.get_synapse_target(ids)

@deprecated
def get_delays(self, ids):
    return self.get_synapse_delay(ids)

@deprecated
def get_weights(self, ids):
    return self.get_synapse_weight(ids)

@deprecated
def get_plastic(self, ids):
    return self.get_synapse_plastic(ids)

Simulation.get_targets = get_targets
Simulation.get_delays = get_delays
Simulation.get_weights = get_weights
Simulation.get_plastic = get_plastic


__version__ = '@NEMO_VERSION@'
__all__ = ['Network', 'Simulation', 'Configuration']
