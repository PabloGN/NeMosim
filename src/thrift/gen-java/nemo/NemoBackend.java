/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package nemo;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import org.apache.log4j.Logger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class NemoBackend {

  public interface Iface {

    public void addCluster(List<IzhNeuron> cluster) throws TException;

    public void addNeuron(IzhNeuron neuron) throws ConstructionError, TException;

    public void enableStdp(List<Double> prefire, List<Double> postfire, double maxWeight, double minWeight) throws ConstructionError, TException;

    public void enablePipelining() throws TException;

    public PipelineLength pipelineLength() throws TException;

    public void startSimulation() throws ConstructionError, TException;

    public List<List<Integer>> run(List<Stimulus> stim) throws ConstructionError, TException;

    public void applyStdp(double reward) throws ConstructionError, TException;

    public Map<Integer,List<Synapse>> getConnectivity() throws TException;

    public void stopSimulation() throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void addCluster(List<IzhNeuron> cluster) throws TException
    {
      send_addCluster(cluster);
      recv_addCluster();
    }

    public void send_addCluster(List<IzhNeuron> cluster) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("addCluster", TMessageType.CALL, seqid_));
      addCluster_args args = new addCluster_args();
      args.cluster = cluster;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_addCluster() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addCluster_result result = new addCluster_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void addNeuron(IzhNeuron neuron) throws ConstructionError, TException
    {
      send_addNeuron(neuron);
      recv_addNeuron();
    }

    public void send_addNeuron(IzhNeuron neuron) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("addNeuron", TMessageType.CALL, seqid_));
      addNeuron_args args = new addNeuron_args();
      args.neuron = neuron;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_addNeuron() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addNeuron_result result = new addNeuron_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public void enableStdp(List<Double> prefire, List<Double> postfire, double maxWeight, double minWeight) throws ConstructionError, TException
    {
      send_enableStdp(prefire, postfire, maxWeight, minWeight);
      recv_enableStdp();
    }

    public void send_enableStdp(List<Double> prefire, List<Double> postfire, double maxWeight, double minWeight) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enableStdp", TMessageType.CALL, seqid_));
      enableStdp_args args = new enableStdp_args();
      args.prefire = prefire;
      args.postfire = postfire;
      args.maxWeight = maxWeight;
      args.minWeight = minWeight;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enableStdp() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      enableStdp_result result = new enableStdp_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public void enablePipelining() throws TException
    {
      send_enablePipelining();
      recv_enablePipelining();
    }

    public void send_enablePipelining() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enablePipelining", TMessageType.CALL, seqid_));
      enablePipelining_args args = new enablePipelining_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enablePipelining() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      enablePipelining_result result = new enablePipelining_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public PipelineLength pipelineLength() throws TException
    {
      send_pipelineLength();
      return recv_pipelineLength();
    }

    public void send_pipelineLength() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("pipelineLength", TMessageType.CALL, seqid_));
      pipelineLength_args args = new pipelineLength_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public PipelineLength recv_pipelineLength() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      pipelineLength_result result = new pipelineLength_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "pipelineLength failed: unknown result");
    }

    public void startSimulation() throws ConstructionError, TException
    {
      send_startSimulation();
      recv_startSimulation();
    }

    public void send_startSimulation() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("startSimulation", TMessageType.CALL, seqid_));
      startSimulation_args args = new startSimulation_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_startSimulation() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      startSimulation_result result = new startSimulation_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public List<List<Integer>> run(List<Stimulus> stim) throws ConstructionError, TException
    {
      send_run(stim);
      return recv_run();
    }

    public void send_run(List<Stimulus> stim) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("run", TMessageType.CALL, seqid_));
      run_args args = new run_args();
      args.stim = stim;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<Integer>> recv_run() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      run_result result = new run_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "run failed: unknown result");
    }

    public void applyStdp(double reward) throws ConstructionError, TException
    {
      send_applyStdp(reward);
      recv_applyStdp();
    }

    public void send_applyStdp(double reward) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("applyStdp", TMessageType.CALL, seqid_));
      applyStdp_args args = new applyStdp_args();
      args.reward = reward;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_applyStdp() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      applyStdp_result result = new applyStdp_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public Map<Integer,List<Synapse>> getConnectivity() throws TException
    {
      send_getConnectivity();
      return recv_getConnectivity();
    }

    public void send_getConnectivity() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getConnectivity", TMessageType.CALL, seqid_));
      getConnectivity_args args = new getConnectivity_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<Integer,List<Synapse>> recv_getConnectivity() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getConnectivity_result result = new getConnectivity_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConnectivity failed: unknown result");
    }

    public void stopSimulation() throws TException
    {
      send_stopSimulation();
    }

    public void send_stopSimulation() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("stopSimulation", TMessageType.CALL, seqid_));
      stopSimulation_args args = new stopSimulation_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("addCluster", new addCluster());
      processMap_.put("addNeuron", new addNeuron());
      processMap_.put("enableStdp", new enableStdp());
      processMap_.put("enablePipelining", new enablePipelining());
      processMap_.put("pipelineLength", new pipelineLength());
      processMap_.put("startSimulation", new startSimulation());
      processMap_.put("run", new run());
      processMap_.put("applyStdp", new applyStdp());
      processMap_.put("getConnectivity", new getConnectivity());
      processMap_.put("stopSimulation", new stopSimulation());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class addCluster implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        addCluster_args args = new addCluster_args();
        args.read(iprot);
        iprot.readMessageEnd();
        addCluster_result result = new addCluster_result();
        iface_.addCluster(args.cluster);
        oprot.writeMessageBegin(new TMessage("addCluster", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class addNeuron implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        addNeuron_args args = new addNeuron_args();
        args.read(iprot);
        iprot.readMessageEnd();
        addNeuron_result result = new addNeuron_result();
        try {
          iface_.addNeuron(args.neuron);
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing addNeuron", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing addNeuron");
          oprot.writeMessageBegin(new TMessage("addNeuron", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("addNeuron", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enableStdp implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enableStdp_args args = new enableStdp_args();
        args.read(iprot);
        iprot.readMessageEnd();
        enableStdp_result result = new enableStdp_result();
        try {
          iface_.enableStdp(args.prefire, args.postfire, args.maxWeight, args.minWeight);
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing enableStdp", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing enableStdp");
          oprot.writeMessageBegin(new TMessage("enableStdp", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("enableStdp", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enablePipelining implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enablePipelining_args args = new enablePipelining_args();
        args.read(iprot);
        iprot.readMessageEnd();
        enablePipelining_result result = new enablePipelining_result();
        iface_.enablePipelining();
        oprot.writeMessageBegin(new TMessage("enablePipelining", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class pipelineLength implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        pipelineLength_args args = new pipelineLength_args();
        args.read(iprot);
        iprot.readMessageEnd();
        pipelineLength_result result = new pipelineLength_result();
        result.success = iface_.pipelineLength();
        oprot.writeMessageBegin(new TMessage("pipelineLength", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class startSimulation implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        startSimulation_args args = new startSimulation_args();
        args.read(iprot);
        iprot.readMessageEnd();
        startSimulation_result result = new startSimulation_result();
        try {
          iface_.startSimulation();
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing startSimulation", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing startSimulation");
          oprot.writeMessageBegin(new TMessage("startSimulation", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("startSimulation", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class run implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        run_args args = new run_args();
        args.read(iprot);
        iprot.readMessageEnd();
        run_result result = new run_result();
        try {
          result.success = iface_.run(args.stim);
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing run", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing run");
          oprot.writeMessageBegin(new TMessage("run", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("run", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class applyStdp implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        applyStdp_args args = new applyStdp_args();
        args.read(iprot);
        iprot.readMessageEnd();
        applyStdp_result result = new applyStdp_result();
        try {
          iface_.applyStdp(args.reward);
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing applyStdp", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing applyStdp");
          oprot.writeMessageBegin(new TMessage("applyStdp", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("applyStdp", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getConnectivity implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getConnectivity_args args = new getConnectivity_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getConnectivity_result result = new getConnectivity_result();
        result.success = iface_.getConnectivity();
        oprot.writeMessageBegin(new TMessage("getConnectivity", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class stopSimulation implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        stopSimulation_args args = new stopSimulation_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.stopSimulation();
        return;
      }
    }

  }

  public static class addCluster_args implements TBase, java.io.Serializable, Cloneable, Comparable<addCluster_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addCluster_args");
    private static final TField CLUSTER_FIELD_DESC = new TField("cluster", TType.LIST, (short)1);

    public List<IzhNeuron> cluster;
    public static final int CLUSTER = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(CLUSTER, new FieldMetaData("cluster", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, IzhNeuron.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(addCluster_args.class, metaDataMap);
    }

    public addCluster_args() {
    }

    public addCluster_args(
      List<IzhNeuron> cluster)
    {
      this();
      this.cluster = cluster;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addCluster_args(addCluster_args other) {
      if (other.isSetCluster()) {
        List<IzhNeuron> __this__cluster = new ArrayList<IzhNeuron>();
        for (IzhNeuron other_element : other.cluster) {
          __this__cluster.add(new IzhNeuron(other_element));
        }
        this.cluster = __this__cluster;
      }
    }

    @Override
    public addCluster_args clone() {
      return new addCluster_args(this);
    }

    public List<IzhNeuron> getCluster() {
      return this.cluster;
    }

    public addCluster_args setCluster(List<IzhNeuron> cluster) {
      this.cluster = cluster;
      return this;
    }

    public void unsetCluster() {
      this.cluster = null;
    }

    // Returns true if field cluster is set (has been asigned a value) and false otherwise
    public boolean isSetCluster() {
      return this.cluster != null;
    }

    public void setClusterIsSet(boolean value) {
      if (!value) {
        this.cluster = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case CLUSTER:
        if (value == null) {
          unsetCluster();
        } else {
          setCluster((List<IzhNeuron>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case CLUSTER:
        return getCluster();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case CLUSTER:
        return isSetCluster();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addCluster_args)
        return this.equals((addCluster_args)that);
      return false;
    }

    public boolean equals(addCluster_args that) {
      if (that == null)
        return false;

      boolean this_present_cluster = true && this.isSetCluster();
      boolean that_present_cluster = true && that.isSetCluster();
      if (this_present_cluster || that_present_cluster) {
        if (!(this_present_cluster && that_present_cluster))
          return false;
        if (!this.cluster.equals(that.cluster))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(addCluster_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addCluster_args typedOther = (addCluster_args)other;

      lastComparison = Boolean.valueOf(isSetCluster()).compareTo(isSetCluster());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(cluster, typedOther.cluster);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case CLUSTER:
            if (field.type == TType.LIST) {
              {
                TList _list37 = iprot.readListBegin();
                this.cluster = new ArrayList<IzhNeuron>(_list37.size);
                for (int _i38 = 0; _i38 < _list37.size; ++_i38)
                {
                  IzhNeuron _elem39;
                  _elem39 = new IzhNeuron();
                  _elem39.read(iprot);
                  this.cluster.add(_elem39);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.cluster != null) {
        oprot.writeFieldBegin(CLUSTER_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.cluster.size()));
          for (IzhNeuron _iter40 : this.cluster)          {
            _iter40.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("addCluster_args(");
      boolean first = true;

      sb.append("cluster:");
      if (this.cluster == null) {
        sb.append("null");
      } else {
        sb.append(this.cluster);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class addCluster_result implements TBase, java.io.Serializable, Cloneable, Comparable<addCluster_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addCluster_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(addCluster_result.class, metaDataMap);
    }

    public addCluster_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addCluster_result(addCluster_result other) {
    }

    @Override
    public addCluster_result clone() {
      return new addCluster_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addCluster_result)
        return this.equals((addCluster_result)that);
      return false;
    }

    public boolean equals(addCluster_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(addCluster_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addCluster_result typedOther = (addCluster_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("addCluster_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class addNeuron_args implements TBase, java.io.Serializable, Cloneable, Comparable<addNeuron_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addNeuron_args");
    private static final TField NEURON_FIELD_DESC = new TField("neuron", TType.STRUCT, (short)1);

    public IzhNeuron neuron;
    public static final int NEURON = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NEURON, new FieldMetaData("neuron", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, IzhNeuron.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(addNeuron_args.class, metaDataMap);
    }

    public addNeuron_args() {
    }

    public addNeuron_args(
      IzhNeuron neuron)
    {
      this();
      this.neuron = neuron;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addNeuron_args(addNeuron_args other) {
      if (other.isSetNeuron()) {
        this.neuron = new IzhNeuron(other.neuron);
      }
    }

    @Override
    public addNeuron_args clone() {
      return new addNeuron_args(this);
    }

    public IzhNeuron getNeuron() {
      return this.neuron;
    }

    public addNeuron_args setNeuron(IzhNeuron neuron) {
      this.neuron = neuron;
      return this;
    }

    public void unsetNeuron() {
      this.neuron = null;
    }

    // Returns true if field neuron is set (has been asigned a value) and false otherwise
    public boolean isSetNeuron() {
      return this.neuron != null;
    }

    public void setNeuronIsSet(boolean value) {
      if (!value) {
        this.neuron = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NEURON:
        if (value == null) {
          unsetNeuron();
        } else {
          setNeuron((IzhNeuron)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NEURON:
        return getNeuron();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NEURON:
        return isSetNeuron();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addNeuron_args)
        return this.equals((addNeuron_args)that);
      return false;
    }

    public boolean equals(addNeuron_args that) {
      if (that == null)
        return false;

      boolean this_present_neuron = true && this.isSetNeuron();
      boolean that_present_neuron = true && that.isSetNeuron();
      if (this_present_neuron || that_present_neuron) {
        if (!(this_present_neuron && that_present_neuron))
          return false;
        if (!this.neuron.equals(that.neuron))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(addNeuron_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addNeuron_args typedOther = (addNeuron_args)other;

      lastComparison = Boolean.valueOf(isSetNeuron()).compareTo(isSetNeuron());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(neuron, typedOther.neuron);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NEURON:
            if (field.type == TType.STRUCT) {
              this.neuron = new IzhNeuron();
              this.neuron.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.neuron != null) {
        oprot.writeFieldBegin(NEURON_FIELD_DESC);
        this.neuron.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("addNeuron_args(");
      boolean first = true;

      sb.append("neuron:");
      if (this.neuron == null) {
        sb.append("null");
      } else {
        sb.append(this.neuron);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class addNeuron_result implements TBase, java.io.Serializable, Cloneable, Comparable<addNeuron_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addNeuron_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(addNeuron_result.class, metaDataMap);
    }

    public addNeuron_result() {
    }

    public addNeuron_result(
      ConstructionError err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addNeuron_result(addNeuron_result other) {
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public addNeuron_result clone() {
      return new addNeuron_result(this);
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public addNeuron_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addNeuron_result)
        return this.equals((addNeuron_result)that);
      return false;
    }

    public boolean equals(addNeuron_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(addNeuron_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addNeuron_result typedOther = (addNeuron_result)other;

      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("addNeuron_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enableStdp_args implements TBase, java.io.Serializable, Cloneable, Comparable<enableStdp_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("enableStdp_args");
    private static final TField PREFIRE_FIELD_DESC = new TField("prefire", TType.LIST, (short)1);
    private static final TField POSTFIRE_FIELD_DESC = new TField("postfire", TType.LIST, (short)2);
    private static final TField MAX_WEIGHT_FIELD_DESC = new TField("maxWeight", TType.DOUBLE, (short)3);
    private static final TField MIN_WEIGHT_FIELD_DESC = new TField("minWeight", TType.DOUBLE, (short)4);

    public List<Double> prefire;
    public static final int PREFIRE = 1;
    public List<Double> postfire;
    public static final int POSTFIRE = 2;
    public double maxWeight;
    public static final int MAXWEIGHT = 3;
    public double minWeight;
    public static final int MINWEIGHT = 4;

    // isset id assignments
    private static final int __MAXWEIGHT_ISSET_ID = 0;
    private static final int __MINWEIGHT_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PREFIRE, new FieldMetaData("prefire", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.DOUBLE))));
      put(POSTFIRE, new FieldMetaData("postfire", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.DOUBLE))));
      put(MAXWEIGHT, new FieldMetaData("maxWeight", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.DOUBLE)));
      put(MINWEIGHT, new FieldMetaData("minWeight", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.DOUBLE)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enableStdp_args.class, metaDataMap);
    }

    public enableStdp_args() {
    }

    public enableStdp_args(
      List<Double> prefire,
      List<Double> postfire,
      double maxWeight,
      double minWeight)
    {
      this();
      this.prefire = prefire;
      this.postfire = postfire;
      this.maxWeight = maxWeight;
      setMaxWeightIsSet(true);
      this.minWeight = minWeight;
      setMinWeightIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enableStdp_args(enableStdp_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetPrefire()) {
        List<Double> __this__prefire = new ArrayList<Double>();
        for (Double other_element : other.prefire) {
          __this__prefire.add(other_element);
        }
        this.prefire = __this__prefire;
      }
      if (other.isSetPostfire()) {
        List<Double> __this__postfire = new ArrayList<Double>();
        for (Double other_element : other.postfire) {
          __this__postfire.add(other_element);
        }
        this.postfire = __this__postfire;
      }
      this.maxWeight = other.maxWeight;
      this.minWeight = other.minWeight;
    }

    @Override
    public enableStdp_args clone() {
      return new enableStdp_args(this);
    }

    public List<Double> getPrefire() {
      return this.prefire;
    }

    public enableStdp_args setPrefire(List<Double> prefire) {
      this.prefire = prefire;
      return this;
    }

    public void unsetPrefire() {
      this.prefire = null;
    }

    // Returns true if field prefire is set (has been asigned a value) and false otherwise
    public boolean isSetPrefire() {
      return this.prefire != null;
    }

    public void setPrefireIsSet(boolean value) {
      if (!value) {
        this.prefire = null;
      }
    }

    public List<Double> getPostfire() {
      return this.postfire;
    }

    public enableStdp_args setPostfire(List<Double> postfire) {
      this.postfire = postfire;
      return this;
    }

    public void unsetPostfire() {
      this.postfire = null;
    }

    // Returns true if field postfire is set (has been asigned a value) and false otherwise
    public boolean isSetPostfire() {
      return this.postfire != null;
    }

    public void setPostfireIsSet(boolean value) {
      if (!value) {
        this.postfire = null;
      }
    }

    public double getMaxWeight() {
      return this.maxWeight;
    }

    public enableStdp_args setMaxWeight(double maxWeight) {
      this.maxWeight = maxWeight;
      setMaxWeightIsSet(true);
      return this;
    }

    public void unsetMaxWeight() {
      __isset_bit_vector.clear(__MAXWEIGHT_ISSET_ID);
    }

    // Returns true if field maxWeight is set (has been asigned a value) and false otherwise
    public boolean isSetMaxWeight() {
      return __isset_bit_vector.get(__MAXWEIGHT_ISSET_ID);
    }

    public void setMaxWeightIsSet(boolean value) {
      __isset_bit_vector.set(__MAXWEIGHT_ISSET_ID, value);
    }

    public double getMinWeight() {
      return this.minWeight;
    }

    public enableStdp_args setMinWeight(double minWeight) {
      this.minWeight = minWeight;
      setMinWeightIsSet(true);
      return this;
    }

    public void unsetMinWeight() {
      __isset_bit_vector.clear(__MINWEIGHT_ISSET_ID);
    }

    // Returns true if field minWeight is set (has been asigned a value) and false otherwise
    public boolean isSetMinWeight() {
      return __isset_bit_vector.get(__MINWEIGHT_ISSET_ID);
    }

    public void setMinWeightIsSet(boolean value) {
      __isset_bit_vector.set(__MINWEIGHT_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PREFIRE:
        if (value == null) {
          unsetPrefire();
        } else {
          setPrefire((List<Double>)value);
        }
        break;

      case POSTFIRE:
        if (value == null) {
          unsetPostfire();
        } else {
          setPostfire((List<Double>)value);
        }
        break;

      case MAXWEIGHT:
        if (value == null) {
          unsetMaxWeight();
        } else {
          setMaxWeight((Double)value);
        }
        break;

      case MINWEIGHT:
        if (value == null) {
          unsetMinWeight();
        } else {
          setMinWeight((Double)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PREFIRE:
        return getPrefire();

      case POSTFIRE:
        return getPostfire();

      case MAXWEIGHT:
        return new Double(getMaxWeight());

      case MINWEIGHT:
        return new Double(getMinWeight());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PREFIRE:
        return isSetPrefire();
      case POSTFIRE:
        return isSetPostfire();
      case MAXWEIGHT:
        return isSetMaxWeight();
      case MINWEIGHT:
        return isSetMinWeight();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enableStdp_args)
        return this.equals((enableStdp_args)that);
      return false;
    }

    public boolean equals(enableStdp_args that) {
      if (that == null)
        return false;

      boolean this_present_prefire = true && this.isSetPrefire();
      boolean that_present_prefire = true && that.isSetPrefire();
      if (this_present_prefire || that_present_prefire) {
        if (!(this_present_prefire && that_present_prefire))
          return false;
        if (!this.prefire.equals(that.prefire))
          return false;
      }

      boolean this_present_postfire = true && this.isSetPostfire();
      boolean that_present_postfire = true && that.isSetPostfire();
      if (this_present_postfire || that_present_postfire) {
        if (!(this_present_postfire && that_present_postfire))
          return false;
        if (!this.postfire.equals(that.postfire))
          return false;
      }

      boolean this_present_maxWeight = true;
      boolean that_present_maxWeight = true;
      if (this_present_maxWeight || that_present_maxWeight) {
        if (!(this_present_maxWeight && that_present_maxWeight))
          return false;
        if (this.maxWeight != that.maxWeight)
          return false;
      }

      boolean this_present_minWeight = true;
      boolean that_present_minWeight = true;
      if (this_present_minWeight || that_present_minWeight) {
        if (!(this_present_minWeight && that_present_minWeight))
          return false;
        if (this.minWeight != that.minWeight)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enableStdp_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enableStdp_args typedOther = (enableStdp_args)other;

      lastComparison = Boolean.valueOf(isSetPrefire()).compareTo(isSetPrefire());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(prefire, typedOther.prefire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetPostfire()).compareTo(isSetPostfire());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(postfire, typedOther.postfire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetMaxWeight()).compareTo(isSetMaxWeight());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(maxWeight, typedOther.maxWeight);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetMinWeight()).compareTo(isSetMinWeight());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(minWeight, typedOther.minWeight);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PREFIRE:
            if (field.type == TType.LIST) {
              {
                TList _list41 = iprot.readListBegin();
                this.prefire = new ArrayList<Double>(_list41.size);
                for (int _i42 = 0; _i42 < _list41.size; ++_i42)
                {
                  double _elem43;
                  _elem43 = iprot.readDouble();
                  this.prefire.add(_elem43);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case POSTFIRE:
            if (field.type == TType.LIST) {
              {
                TList _list44 = iprot.readListBegin();
                this.postfire = new ArrayList<Double>(_list44.size);
                for (int _i45 = 0; _i45 < _list44.size; ++_i45)
                {
                  double _elem46;
                  _elem46 = iprot.readDouble();
                  this.postfire.add(_elem46);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case MAXWEIGHT:
            if (field.type == TType.DOUBLE) {
              this.maxWeight = iprot.readDouble();
              setMaxWeightIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case MINWEIGHT:
            if (field.type == TType.DOUBLE) {
              this.minWeight = iprot.readDouble();
              setMinWeightIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.prefire != null) {
        oprot.writeFieldBegin(PREFIRE_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.DOUBLE, this.prefire.size()));
          for (double _iter47 : this.prefire)          {
            oprot.writeDouble(_iter47);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.postfire != null) {
        oprot.writeFieldBegin(POSTFIRE_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.DOUBLE, this.postfire.size()));
          for (double _iter48 : this.postfire)          {
            oprot.writeDouble(_iter48);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_WEIGHT_FIELD_DESC);
      oprot.writeDouble(this.maxWeight);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MIN_WEIGHT_FIELD_DESC);
      oprot.writeDouble(this.minWeight);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enableStdp_args(");
      boolean first = true;

      sb.append("prefire:");
      if (this.prefire == null) {
        sb.append("null");
      } else {
        sb.append(this.prefire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("postfire:");
      if (this.postfire == null) {
        sb.append("null");
      } else {
        sb.append(this.postfire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("maxWeight:");
      sb.append(this.maxWeight);
      first = false;
      if (!first) sb.append(", ");
      sb.append("minWeight:");
      sb.append(this.minWeight);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enableStdp_result implements TBase, java.io.Serializable, Cloneable, Comparable<enableStdp_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("enableStdp_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enableStdp_result.class, metaDataMap);
    }

    public enableStdp_result() {
    }

    public enableStdp_result(
      ConstructionError err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enableStdp_result(enableStdp_result other) {
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public enableStdp_result clone() {
      return new enableStdp_result(this);
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public enableStdp_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enableStdp_result)
        return this.equals((enableStdp_result)that);
      return false;
    }

    public boolean equals(enableStdp_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enableStdp_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enableStdp_result typedOther = (enableStdp_result)other;

      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enableStdp_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enablePipelining_args implements TBase, java.io.Serializable, Cloneable, Comparable<enablePipelining_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("enablePipelining_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enablePipelining_args.class, metaDataMap);
    }

    public enablePipelining_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enablePipelining_args(enablePipelining_args other) {
    }

    @Override
    public enablePipelining_args clone() {
      return new enablePipelining_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enablePipelining_args)
        return this.equals((enablePipelining_args)that);
      return false;
    }

    public boolean equals(enablePipelining_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enablePipelining_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enablePipelining_args typedOther = (enablePipelining_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enablePipelining_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enablePipelining_result implements TBase, java.io.Serializable, Cloneable, Comparable<enablePipelining_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("enablePipelining_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enablePipelining_result.class, metaDataMap);
    }

    public enablePipelining_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enablePipelining_result(enablePipelining_result other) {
    }

    @Override
    public enablePipelining_result clone() {
      return new enablePipelining_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enablePipelining_result)
        return this.equals((enablePipelining_result)that);
      return false;
    }

    public boolean equals(enablePipelining_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enablePipelining_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enablePipelining_result typedOther = (enablePipelining_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enablePipelining_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class pipelineLength_args implements TBase, java.io.Serializable, Cloneable, Comparable<pipelineLength_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("pipelineLength_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(pipelineLength_args.class, metaDataMap);
    }

    public pipelineLength_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pipelineLength_args(pipelineLength_args other) {
    }

    @Override
    public pipelineLength_args clone() {
      return new pipelineLength_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pipelineLength_args)
        return this.equals((pipelineLength_args)that);
      return false;
    }

    public boolean equals(pipelineLength_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(pipelineLength_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pipelineLength_args typedOther = (pipelineLength_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("pipelineLength_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class pipelineLength_result implements TBase, java.io.Serializable, Cloneable, Comparable<pipelineLength_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("pipelineLength_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public PipelineLength success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, PipelineLength.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(pipelineLength_result.class, metaDataMap);
    }

    public pipelineLength_result() {
    }

    public pipelineLength_result(
      PipelineLength success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pipelineLength_result(pipelineLength_result other) {
      if (other.isSetSuccess()) {
        this.success = new PipelineLength(other.success);
      }
    }

    @Override
    public pipelineLength_result clone() {
      return new pipelineLength_result(this);
    }

    public PipelineLength getSuccess() {
      return this.success;
    }

    public pipelineLength_result setSuccess(PipelineLength success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((PipelineLength)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pipelineLength_result)
        return this.equals((pipelineLength_result)that);
      return false;
    }

    public boolean equals(pipelineLength_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(pipelineLength_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pipelineLength_result typedOther = (pipelineLength_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new PipelineLength();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("pipelineLength_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class startSimulation_args implements TBase, java.io.Serializable, Cloneable, Comparable<startSimulation_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("startSimulation_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(startSimulation_args.class, metaDataMap);
    }

    public startSimulation_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public startSimulation_args(startSimulation_args other) {
    }

    @Override
    public startSimulation_args clone() {
      return new startSimulation_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof startSimulation_args)
        return this.equals((startSimulation_args)that);
      return false;
    }

    public boolean equals(startSimulation_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(startSimulation_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      startSimulation_args typedOther = (startSimulation_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("startSimulation_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class startSimulation_result implements TBase, java.io.Serializable, Cloneable, Comparable<startSimulation_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("startSimulation_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(startSimulation_result.class, metaDataMap);
    }

    public startSimulation_result() {
    }

    public startSimulation_result(
      ConstructionError err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public startSimulation_result(startSimulation_result other) {
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public startSimulation_result clone() {
      return new startSimulation_result(this);
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public startSimulation_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof startSimulation_result)
        return this.equals((startSimulation_result)that);
      return false;
    }

    public boolean equals(startSimulation_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(startSimulation_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      startSimulation_result typedOther = (startSimulation_result)other;

      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("startSimulation_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class run_args implements TBase, java.io.Serializable, Cloneable, Comparable<run_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("run_args");
    private static final TField STIM_FIELD_DESC = new TField("stim", TType.LIST, (short)1);

    public List<Stimulus> stim;
    public static final int STIM = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(STIM, new FieldMetaData("stim", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Stimulus.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(run_args.class, metaDataMap);
    }

    public run_args() {
    }

    public run_args(
      List<Stimulus> stim)
    {
      this();
      this.stim = stim;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public run_args(run_args other) {
      if (other.isSetStim()) {
        List<Stimulus> __this__stim = new ArrayList<Stimulus>();
        for (Stimulus other_element : other.stim) {
          __this__stim.add(new Stimulus(other_element));
        }
        this.stim = __this__stim;
      }
    }

    @Override
    public run_args clone() {
      return new run_args(this);
    }

    public List<Stimulus> getStim() {
      return this.stim;
    }

    public run_args setStim(List<Stimulus> stim) {
      this.stim = stim;
      return this;
    }

    public void unsetStim() {
      this.stim = null;
    }

    // Returns true if field stim is set (has been asigned a value) and false otherwise
    public boolean isSetStim() {
      return this.stim != null;
    }

    public void setStimIsSet(boolean value) {
      if (!value) {
        this.stim = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case STIM:
        if (value == null) {
          unsetStim();
        } else {
          setStim((List<Stimulus>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case STIM:
        return getStim();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case STIM:
        return isSetStim();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof run_args)
        return this.equals((run_args)that);
      return false;
    }

    public boolean equals(run_args that) {
      if (that == null)
        return false;

      boolean this_present_stim = true && this.isSetStim();
      boolean that_present_stim = true && that.isSetStim();
      if (this_present_stim || that_present_stim) {
        if (!(this_present_stim && that_present_stim))
          return false;
        if (!this.stim.equals(that.stim))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(run_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      run_args typedOther = (run_args)other;

      lastComparison = Boolean.valueOf(isSetStim()).compareTo(isSetStim());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(stim, typedOther.stim);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case STIM:
            if (field.type == TType.LIST) {
              {
                TList _list49 = iprot.readListBegin();
                this.stim = new ArrayList<Stimulus>(_list49.size);
                for (int _i50 = 0; _i50 < _list49.size; ++_i50)
                {
                  Stimulus _elem51;
                  _elem51 = new Stimulus();
                  _elem51.read(iprot);
                  this.stim.add(_elem51);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.stim != null) {
        oprot.writeFieldBegin(STIM_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.stim.size()));
          for (Stimulus _iter52 : this.stim)          {
            _iter52.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("run_args(");
      boolean first = true;

      sb.append("stim:");
      if (this.stim == null) {
        sb.append("null");
      } else {
        sb.append(this.stim);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class run_result implements TBase, java.io.Serializable, Cloneable, Comparable<run_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("run_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public List<List<Integer>> success;
    public static final int SUCCESS = 0;
    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST))));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(run_result.class, metaDataMap);
    }

    public run_result() {
    }

    public run_result(
      List<List<Integer>> success,
      ConstructionError err)
    {
      this();
      this.success = success;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public run_result(run_result other) {
      if (other.isSetSuccess()) {
        List<List<Integer>> __this__success = new ArrayList<List<Integer>>();
        for (List<Integer> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public run_result clone() {
      return new run_result(this);
    }

    public List<List<Integer>> getSuccess() {
      return this.success;
    }

    public run_result setSuccess(List<List<Integer>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public run_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<Integer>>)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof run_result)
        return this.equals((run_result)that);
      return false;
    }

    public boolean equals(run_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(run_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      run_result typedOther = (run_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list53 = iprot.readListBegin();
                this.success = new ArrayList<List<Integer>>(_list53.size);
                for (int _i54 = 0; _i54 < _list53.size; ++_i54)
                {
                  List<Integer> _elem55;
                  {
                    TList _list56 = iprot.readListBegin();
                    _elem55 = new ArrayList<Integer>(_list56.size);
                    for (int _i57 = 0; _i57 < _list56.size; ++_i57)
                    {
                      int _elem58;
                      _elem58 = iprot.readI32();
                      _elem55.add(_elem58);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem55);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<Integer> _iter59 : this.success)          {
            {
              oprot.writeListBegin(new TList(TType.I32, _iter59.size()));
              for (int _iter60 : _iter59)              {
                oprot.writeI32(_iter60);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("run_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class applyStdp_args implements TBase, java.io.Serializable, Cloneable, Comparable<applyStdp_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("applyStdp_args");
    private static final TField REWARD_FIELD_DESC = new TField("reward", TType.DOUBLE, (short)1);

    public double reward;
    public static final int REWARD = 1;

    // isset id assignments
    private static final int __REWARD_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(REWARD, new FieldMetaData("reward", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.DOUBLE)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(applyStdp_args.class, metaDataMap);
    }

    public applyStdp_args() {
    }

    public applyStdp_args(
      double reward)
    {
      this();
      this.reward = reward;
      setRewardIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public applyStdp_args(applyStdp_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.reward = other.reward;
    }

    @Override
    public applyStdp_args clone() {
      return new applyStdp_args(this);
    }

    public double getReward() {
      return this.reward;
    }

    public applyStdp_args setReward(double reward) {
      this.reward = reward;
      setRewardIsSet(true);
      return this;
    }

    public void unsetReward() {
      __isset_bit_vector.clear(__REWARD_ISSET_ID);
    }

    // Returns true if field reward is set (has been asigned a value) and false otherwise
    public boolean isSetReward() {
      return __isset_bit_vector.get(__REWARD_ISSET_ID);
    }

    public void setRewardIsSet(boolean value) {
      __isset_bit_vector.set(__REWARD_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REWARD:
        if (value == null) {
          unsetReward();
        } else {
          setReward((Double)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REWARD:
        return new Double(getReward());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REWARD:
        return isSetReward();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof applyStdp_args)
        return this.equals((applyStdp_args)that);
      return false;
    }

    public boolean equals(applyStdp_args that) {
      if (that == null)
        return false;

      boolean this_present_reward = true;
      boolean that_present_reward = true;
      if (this_present_reward || that_present_reward) {
        if (!(this_present_reward && that_present_reward))
          return false;
        if (this.reward != that.reward)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(applyStdp_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      applyStdp_args typedOther = (applyStdp_args)other;

      lastComparison = Boolean.valueOf(isSetReward()).compareTo(isSetReward());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(reward, typedOther.reward);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REWARD:
            if (field.type == TType.DOUBLE) {
              this.reward = iprot.readDouble();
              setRewardIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(REWARD_FIELD_DESC);
      oprot.writeDouble(this.reward);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("applyStdp_args(");
      boolean first = true;

      sb.append("reward:");
      sb.append(this.reward);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class applyStdp_result implements TBase, java.io.Serializable, Cloneable, Comparable<applyStdp_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("applyStdp_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(applyStdp_result.class, metaDataMap);
    }

    public applyStdp_result() {
    }

    public applyStdp_result(
      ConstructionError err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public applyStdp_result(applyStdp_result other) {
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public applyStdp_result clone() {
      return new applyStdp_result(this);
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public applyStdp_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof applyStdp_result)
        return this.equals((applyStdp_result)that);
      return false;
    }

    public boolean equals(applyStdp_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(applyStdp_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      applyStdp_result typedOther = (applyStdp_result)other;

      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("applyStdp_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getConnectivity_args implements TBase, java.io.Serializable, Cloneable, Comparable<getConnectivity_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getConnectivity_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getConnectivity_args.class, metaDataMap);
    }

    public getConnectivity_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConnectivity_args(getConnectivity_args other) {
    }

    @Override
    public getConnectivity_args clone() {
      return new getConnectivity_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConnectivity_args)
        return this.equals((getConnectivity_args)that);
      return false;
    }

    public boolean equals(getConnectivity_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConnectivity_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConnectivity_args typedOther = (getConnectivity_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getConnectivity_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getConnectivity_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConnectivity_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<Integer,List<Synapse>> success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.I32), 
              new FieldValueMetaData(TType.LIST))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getConnectivity_result.class, metaDataMap);
    }

    public getConnectivity_result() {
    }

    public getConnectivity_result(
      Map<Integer,List<Synapse>> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConnectivity_result(getConnectivity_result other) {
      if (other.isSetSuccess()) {
        Map<Integer,List<Synapse>> __this__success = new HashMap<Integer,List<Synapse>>();
        for (Map.Entry<Integer, List<Synapse>> other_element : other.success.entrySet()) {

          Integer other_element_key = other_element.getKey();
          List<Synapse> other_element_value = other_element.getValue();

          Integer __this__success_copy_key = other_element_key;

          List<Synapse> __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    @Override
    public getConnectivity_result clone() {
      return new getConnectivity_result(this);
    }

    public Map<Integer,List<Synapse>> getSuccess() {
      return this.success;
    }

    public getConnectivity_result setSuccess(Map<Integer,List<Synapse>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<Integer,List<Synapse>>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConnectivity_result)
        return this.equals((getConnectivity_result)that);
      return false;
    }

    public boolean equals(getConnectivity_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.MAP) {
              {
                TMap _map61 = iprot.readMapBegin();
                this.success = new HashMap<Integer,List<Synapse>>(2*_map61.size);
                for (int _i62 = 0; _i62 < _map61.size; ++_i62)
                {
                  int _key63;
                  List<Synapse> _val64;
                  _key63 = iprot.readI32();
                  {
                    TList _list65 = iprot.readListBegin();
                    _val64 = new ArrayList<Synapse>(_list65.size);
                    for (int _i66 = 0; _i66 < _list65.size; ++_i66)
                    {
                      Synapse _elem67;
                      _elem67 = new Synapse();
                      _elem67.read(iprot);
                      _val64.add(_elem67);
                    }
                    iprot.readListEnd();
                  }
                  this.success.put(_key63, _val64);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.I32, TType.LIST, this.success.size()));
          for (Map.Entry<Integer, List<Synapse>> _iter68 : this.success.entrySet())          {
            oprot.writeI32(_iter68.getKey());
            {
              oprot.writeListBegin(new TList(TType.STRUCT, _iter68.getValue().size()));
              for (Synapse _iter69 : _iter68.getValue())              {
                _iter69.write(oprot);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getConnectivity_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class stopSimulation_args implements TBase, java.io.Serializable, Cloneable, Comparable<stopSimulation_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("stopSimulation_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(stopSimulation_args.class, metaDataMap);
    }

    public stopSimulation_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stopSimulation_args(stopSimulation_args other) {
    }

    @Override
    public stopSimulation_args clone() {
      return new stopSimulation_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stopSimulation_args)
        return this.equals((stopSimulation_args)that);
      return false;
    }

    public boolean equals(stopSimulation_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(stopSimulation_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      stopSimulation_args typedOther = (stopSimulation_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("stopSimulation_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
