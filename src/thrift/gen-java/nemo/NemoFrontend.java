/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package nemo;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.Collections;
import java.util.BitSet;
import org.apache.log4j.Logger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class NemoFrontend {

  public interface Iface {

    public void setBackend(String host) throws TException;

    public void enableStdp(List<Double> prefire, List<Double> postfire, double maxWeight, double minWeight) throws TException;

    public void enablePipelining() throws TException;

    public PipelineLength pipelineLength() throws TException;

    public void disableStdp() throws TException;

    public void addNeuron(IzhNeuron neuron) throws ConstructionError, TException;

    public void startSimulation() throws ConstructionError, TException;

    public List<List<Integer>> run(List<Stimulus> stim) throws ConstructionError, TException;

    public void applyStdp(double reward) throws ConstructionError, TException;

    public Map<Integer,List<Synapse>> getConnectivity() throws TException;

    public void stopSimulation() throws TException;

    public void reset() throws TException;

    public void terminate() throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void setBackend(String host) throws TException
    {
      send_setBackend(host);
      recv_setBackend();
    }

    public void send_setBackend(String host) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setBackend", TMessageType.CALL, seqid_));
      setBackend_args args = new setBackend_args();
      args.host = host;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setBackend() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      setBackend_result result = new setBackend_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void enableStdp(List<Double> prefire, List<Double> postfire, double maxWeight, double minWeight) throws TException
    {
      send_enableStdp(prefire, postfire, maxWeight, minWeight);
      recv_enableStdp();
    }

    public void send_enableStdp(List<Double> prefire, List<Double> postfire, double maxWeight, double minWeight) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enableStdp", TMessageType.CALL, seqid_));
      enableStdp_args args = new enableStdp_args();
      args.prefire = prefire;
      args.postfire = postfire;
      args.maxWeight = maxWeight;
      args.minWeight = minWeight;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enableStdp() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      enableStdp_result result = new enableStdp_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void enablePipelining() throws TException
    {
      send_enablePipelining();
      recv_enablePipelining();
    }

    public void send_enablePipelining() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("enablePipelining", TMessageType.CALL, seqid_));
      enablePipelining_args args = new enablePipelining_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_enablePipelining() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      enablePipelining_result result = new enablePipelining_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public PipelineLength pipelineLength() throws TException
    {
      send_pipelineLength();
      return recv_pipelineLength();
    }

    public void send_pipelineLength() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("pipelineLength", TMessageType.CALL, seqid_));
      pipelineLength_args args = new pipelineLength_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public PipelineLength recv_pipelineLength() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      pipelineLength_result result = new pipelineLength_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "pipelineLength failed: unknown result");
    }

    public void disableStdp() throws TException
    {
      send_disableStdp();
      recv_disableStdp();
    }

    public void send_disableStdp() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("disableStdp", TMessageType.CALL, seqid_));
      disableStdp_args args = new disableStdp_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_disableStdp() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      disableStdp_result result = new disableStdp_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void addNeuron(IzhNeuron neuron) throws ConstructionError, TException
    {
      send_addNeuron(neuron);
      recv_addNeuron();
    }

    public void send_addNeuron(IzhNeuron neuron) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("addNeuron", TMessageType.CALL, seqid_));
      addNeuron_args args = new addNeuron_args();
      args.neuron = neuron;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_addNeuron() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      addNeuron_result result = new addNeuron_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public void startSimulation() throws ConstructionError, TException
    {
      send_startSimulation();
      recv_startSimulation();
    }

    public void send_startSimulation() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("startSimulation", TMessageType.CALL, seqid_));
      startSimulation_args args = new startSimulation_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_startSimulation() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      startSimulation_result result = new startSimulation_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public List<List<Integer>> run(List<Stimulus> stim) throws ConstructionError, TException
    {
      send_run(stim);
      return recv_run();
    }

    public void send_run(List<Stimulus> stim) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("run", TMessageType.CALL, seqid_));
      run_args args = new run_args();
      args.stim = stim;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<List<Integer>> recv_run() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      run_result result = new run_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.err != null) {
        throw result.err;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "run failed: unknown result");
    }

    public void applyStdp(double reward) throws ConstructionError, TException
    {
      send_applyStdp(reward);
      recv_applyStdp();
    }

    public void send_applyStdp(double reward) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("applyStdp", TMessageType.CALL, seqid_));
      applyStdp_args args = new applyStdp_args();
      args.reward = reward;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_applyStdp() throws ConstructionError, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      applyStdp_result result = new applyStdp_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.err != null) {
        throw result.err;
      }
      return;
    }

    public Map<Integer,List<Synapse>> getConnectivity() throws TException
    {
      send_getConnectivity();
      return recv_getConnectivity();
    }

    public void send_getConnectivity() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getConnectivity", TMessageType.CALL, seqid_));
      getConnectivity_args args = new getConnectivity_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<Integer,List<Synapse>> recv_getConnectivity() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      getConnectivity_result result = new getConnectivity_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getConnectivity failed: unknown result");
    }

    public void stopSimulation() throws TException
    {
      send_stopSimulation();
      recv_stopSimulation();
    }

    public void send_stopSimulation() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("stopSimulation", TMessageType.CALL, seqid_));
      stopSimulation_args args = new stopSimulation_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_stopSimulation() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      stopSimulation_result result = new stopSimulation_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void reset() throws TException
    {
      send_reset();
      recv_reset();
    }

    public void send_reset() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("reset", TMessageType.CALL, seqid_));
      reset_args args = new reset_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_reset() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      reset_result result = new reset_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      return;
    }

    public void terminate() throws TException
    {
      send_terminate();
    }

    public void send_terminate() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("terminate", TMessageType.CALL, seqid_));
      terminate_args args = new terminate_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("setBackend", new setBackend());
      processMap_.put("enableStdp", new enableStdp());
      processMap_.put("enablePipelining", new enablePipelining());
      processMap_.put("pipelineLength", new pipelineLength());
      processMap_.put("disableStdp", new disableStdp());
      processMap_.put("addNeuron", new addNeuron());
      processMap_.put("startSimulation", new startSimulation());
      processMap_.put("run", new run());
      processMap_.put("applyStdp", new applyStdp());
      processMap_.put("getConnectivity", new getConnectivity());
      processMap_.put("stopSimulation", new stopSimulation());
      processMap_.put("reset", new reset());
      processMap_.put("terminate", new terminate());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class setBackend implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setBackend_args args = new setBackend_args();
        args.read(iprot);
        iprot.readMessageEnd();
        setBackend_result result = new setBackend_result();
        iface_.setBackend(args.host);
        oprot.writeMessageBegin(new TMessage("setBackend", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enableStdp implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enableStdp_args args = new enableStdp_args();
        args.read(iprot);
        iprot.readMessageEnd();
        enableStdp_result result = new enableStdp_result();
        iface_.enableStdp(args.prefire, args.postfire, args.maxWeight, args.minWeight);
        oprot.writeMessageBegin(new TMessage("enableStdp", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class enablePipelining implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        enablePipelining_args args = new enablePipelining_args();
        args.read(iprot);
        iprot.readMessageEnd();
        enablePipelining_result result = new enablePipelining_result();
        iface_.enablePipelining();
        oprot.writeMessageBegin(new TMessage("enablePipelining", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class pipelineLength implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        pipelineLength_args args = new pipelineLength_args();
        args.read(iprot);
        iprot.readMessageEnd();
        pipelineLength_result result = new pipelineLength_result();
        result.success = iface_.pipelineLength();
        oprot.writeMessageBegin(new TMessage("pipelineLength", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class disableStdp implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        disableStdp_args args = new disableStdp_args();
        args.read(iprot);
        iprot.readMessageEnd();
        disableStdp_result result = new disableStdp_result();
        iface_.disableStdp();
        oprot.writeMessageBegin(new TMessage("disableStdp", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class addNeuron implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        addNeuron_args args = new addNeuron_args();
        args.read(iprot);
        iprot.readMessageEnd();
        addNeuron_result result = new addNeuron_result();
        try {
          iface_.addNeuron(args.neuron);
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing addNeuron", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing addNeuron");
          oprot.writeMessageBegin(new TMessage("addNeuron", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("addNeuron", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class startSimulation implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        startSimulation_args args = new startSimulation_args();
        args.read(iprot);
        iprot.readMessageEnd();
        startSimulation_result result = new startSimulation_result();
        try {
          iface_.startSimulation();
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing startSimulation", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing startSimulation");
          oprot.writeMessageBegin(new TMessage("startSimulation", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("startSimulation", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class run implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        run_args args = new run_args();
        args.read(iprot);
        iprot.readMessageEnd();
        run_result result = new run_result();
        try {
          result.success = iface_.run(args.stim);
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing run", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing run");
          oprot.writeMessageBegin(new TMessage("run", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("run", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class applyStdp implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        applyStdp_args args = new applyStdp_args();
        args.read(iprot);
        iprot.readMessageEnd();
        applyStdp_result result = new applyStdp_result();
        try {
          iface_.applyStdp(args.reward);
        } catch (ConstructionError err) {
          result.err = err;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing applyStdp", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing applyStdp");
          oprot.writeMessageBegin(new TMessage("applyStdp", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("applyStdp", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getConnectivity implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getConnectivity_args args = new getConnectivity_args();
        args.read(iprot);
        iprot.readMessageEnd();
        getConnectivity_result result = new getConnectivity_result();
        result.success = iface_.getConnectivity();
        oprot.writeMessageBegin(new TMessage("getConnectivity", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class stopSimulation implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        stopSimulation_args args = new stopSimulation_args();
        args.read(iprot);
        iprot.readMessageEnd();
        stopSimulation_result result = new stopSimulation_result();
        iface_.stopSimulation();
        oprot.writeMessageBegin(new TMessage("stopSimulation", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class reset implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        reset_args args = new reset_args();
        args.read(iprot);
        iprot.readMessageEnd();
        reset_result result = new reset_result();
        iface_.reset();
        oprot.writeMessageBegin(new TMessage("reset", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class terminate implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        terminate_args args = new terminate_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.terminate();
        return;
      }
    }

  }

  public static class setBackend_args implements TBase, java.io.Serializable, Cloneable, Comparable<setBackend_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("setBackend_args");
    private static final TField HOST_FIELD_DESC = new TField("host", TType.STRING, (short)1);

    public String host;
    public static final int HOST = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(HOST, new FieldMetaData("host", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setBackend_args.class, metaDataMap);
    }

    public setBackend_args() {
    }

    public setBackend_args(
      String host)
    {
      this();
      this.host = host;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setBackend_args(setBackend_args other) {
      if (other.isSetHost()) {
        this.host = other.host;
      }
    }

    @Override
    public setBackend_args clone() {
      return new setBackend_args(this);
    }

    public String getHost() {
      return this.host;
    }

    public setBackend_args setHost(String host) {
      this.host = host;
      return this;
    }

    public void unsetHost() {
      this.host = null;
    }

    // Returns true if field host is set (has been asigned a value) and false otherwise
    public boolean isSetHost() {
      return this.host != null;
    }

    public void setHostIsSet(boolean value) {
      if (!value) {
        this.host = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case HOST:
        if (value == null) {
          unsetHost();
        } else {
          setHost((String)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case HOST:
        return getHost();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case HOST:
        return isSetHost();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setBackend_args)
        return this.equals((setBackend_args)that);
      return false;
    }

    public boolean equals(setBackend_args that) {
      if (that == null)
        return false;

      boolean this_present_host = true && this.isSetHost();
      boolean that_present_host = true && that.isSetHost();
      if (this_present_host || that_present_host) {
        if (!(this_present_host && that_present_host))
          return false;
        if (!this.host.equals(that.host))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(setBackend_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setBackend_args typedOther = (setBackend_args)other;

      lastComparison = Boolean.valueOf(isSetHost()).compareTo(isSetHost());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(host, typedOther.host);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case HOST:
            if (field.type == TType.STRING) {
              this.host = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.host != null) {
        oprot.writeFieldBegin(HOST_FIELD_DESC);
        oprot.writeString(this.host);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setBackend_args(");
      boolean first = true;

      sb.append("host:");
      if (this.host == null) {
        sb.append("null");
      } else {
        sb.append(this.host);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class setBackend_result implements TBase, java.io.Serializable, Cloneable, Comparable<setBackend_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("setBackend_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(setBackend_result.class, metaDataMap);
    }

    public setBackend_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setBackend_result(setBackend_result other) {
    }

    @Override
    public setBackend_result clone() {
      return new setBackend_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setBackend_result)
        return this.equals((setBackend_result)that);
      return false;
    }

    public boolean equals(setBackend_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(setBackend_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setBackend_result typedOther = (setBackend_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setBackend_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enableStdp_args implements TBase, java.io.Serializable, Cloneable, Comparable<enableStdp_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("enableStdp_args");
    private static final TField PREFIRE_FIELD_DESC = new TField("prefire", TType.LIST, (short)1);
    private static final TField POSTFIRE_FIELD_DESC = new TField("postfire", TType.LIST, (short)2);
    private static final TField MAX_WEIGHT_FIELD_DESC = new TField("maxWeight", TType.DOUBLE, (short)3);
    private static final TField MIN_WEIGHT_FIELD_DESC = new TField("minWeight", TType.DOUBLE, (short)4);

    public List<Double> prefire;
    public static final int PREFIRE = 1;
    public List<Double> postfire;
    public static final int POSTFIRE = 2;
    public double maxWeight;
    public static final int MAXWEIGHT = 3;
    public double minWeight;
    public static final int MINWEIGHT = 4;

    // isset id assignments
    private static final int __MAXWEIGHT_ISSET_ID = 0;
    private static final int __MINWEIGHT_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(PREFIRE, new FieldMetaData("prefire", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.DOUBLE))));
      put(POSTFIRE, new FieldMetaData("postfire", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.DOUBLE))));
      put(MAXWEIGHT, new FieldMetaData("maxWeight", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.DOUBLE)));
      put(MINWEIGHT, new FieldMetaData("minWeight", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.DOUBLE)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enableStdp_args.class, metaDataMap);
    }

    public enableStdp_args() {
    }

    public enableStdp_args(
      List<Double> prefire,
      List<Double> postfire,
      double maxWeight,
      double minWeight)
    {
      this();
      this.prefire = prefire;
      this.postfire = postfire;
      this.maxWeight = maxWeight;
      setMaxWeightIsSet(true);
      this.minWeight = minWeight;
      setMinWeightIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enableStdp_args(enableStdp_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetPrefire()) {
        List<Double> __this__prefire = new ArrayList<Double>();
        for (Double other_element : other.prefire) {
          __this__prefire.add(other_element);
        }
        this.prefire = __this__prefire;
      }
      if (other.isSetPostfire()) {
        List<Double> __this__postfire = new ArrayList<Double>();
        for (Double other_element : other.postfire) {
          __this__postfire.add(other_element);
        }
        this.postfire = __this__postfire;
      }
      this.maxWeight = other.maxWeight;
      this.minWeight = other.minWeight;
    }

    @Override
    public enableStdp_args clone() {
      return new enableStdp_args(this);
    }

    public List<Double> getPrefire() {
      return this.prefire;
    }

    public enableStdp_args setPrefire(List<Double> prefire) {
      this.prefire = prefire;
      return this;
    }

    public void unsetPrefire() {
      this.prefire = null;
    }

    // Returns true if field prefire is set (has been asigned a value) and false otherwise
    public boolean isSetPrefire() {
      return this.prefire != null;
    }

    public void setPrefireIsSet(boolean value) {
      if (!value) {
        this.prefire = null;
      }
    }

    public List<Double> getPostfire() {
      return this.postfire;
    }

    public enableStdp_args setPostfire(List<Double> postfire) {
      this.postfire = postfire;
      return this;
    }

    public void unsetPostfire() {
      this.postfire = null;
    }

    // Returns true if field postfire is set (has been asigned a value) and false otherwise
    public boolean isSetPostfire() {
      return this.postfire != null;
    }

    public void setPostfireIsSet(boolean value) {
      if (!value) {
        this.postfire = null;
      }
    }

    public double getMaxWeight() {
      return this.maxWeight;
    }

    public enableStdp_args setMaxWeight(double maxWeight) {
      this.maxWeight = maxWeight;
      setMaxWeightIsSet(true);
      return this;
    }

    public void unsetMaxWeight() {
      __isset_bit_vector.clear(__MAXWEIGHT_ISSET_ID);
    }

    // Returns true if field maxWeight is set (has been asigned a value) and false otherwise
    public boolean isSetMaxWeight() {
      return __isset_bit_vector.get(__MAXWEIGHT_ISSET_ID);
    }

    public void setMaxWeightIsSet(boolean value) {
      __isset_bit_vector.set(__MAXWEIGHT_ISSET_ID, value);
    }

    public double getMinWeight() {
      return this.minWeight;
    }

    public enableStdp_args setMinWeight(double minWeight) {
      this.minWeight = minWeight;
      setMinWeightIsSet(true);
      return this;
    }

    public void unsetMinWeight() {
      __isset_bit_vector.clear(__MINWEIGHT_ISSET_ID);
    }

    // Returns true if field minWeight is set (has been asigned a value) and false otherwise
    public boolean isSetMinWeight() {
      return __isset_bit_vector.get(__MINWEIGHT_ISSET_ID);
    }

    public void setMinWeightIsSet(boolean value) {
      __isset_bit_vector.set(__MINWEIGHT_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case PREFIRE:
        if (value == null) {
          unsetPrefire();
        } else {
          setPrefire((List<Double>)value);
        }
        break;

      case POSTFIRE:
        if (value == null) {
          unsetPostfire();
        } else {
          setPostfire((List<Double>)value);
        }
        break;

      case MAXWEIGHT:
        if (value == null) {
          unsetMaxWeight();
        } else {
          setMaxWeight((Double)value);
        }
        break;

      case MINWEIGHT:
        if (value == null) {
          unsetMinWeight();
        } else {
          setMinWeight((Double)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case PREFIRE:
        return getPrefire();

      case POSTFIRE:
        return getPostfire();

      case MAXWEIGHT:
        return new Double(getMaxWeight());

      case MINWEIGHT:
        return new Double(getMinWeight());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case PREFIRE:
        return isSetPrefire();
      case POSTFIRE:
        return isSetPostfire();
      case MAXWEIGHT:
        return isSetMaxWeight();
      case MINWEIGHT:
        return isSetMinWeight();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enableStdp_args)
        return this.equals((enableStdp_args)that);
      return false;
    }

    public boolean equals(enableStdp_args that) {
      if (that == null)
        return false;

      boolean this_present_prefire = true && this.isSetPrefire();
      boolean that_present_prefire = true && that.isSetPrefire();
      if (this_present_prefire || that_present_prefire) {
        if (!(this_present_prefire && that_present_prefire))
          return false;
        if (!this.prefire.equals(that.prefire))
          return false;
      }

      boolean this_present_postfire = true && this.isSetPostfire();
      boolean that_present_postfire = true && that.isSetPostfire();
      if (this_present_postfire || that_present_postfire) {
        if (!(this_present_postfire && that_present_postfire))
          return false;
        if (!this.postfire.equals(that.postfire))
          return false;
      }

      boolean this_present_maxWeight = true;
      boolean that_present_maxWeight = true;
      if (this_present_maxWeight || that_present_maxWeight) {
        if (!(this_present_maxWeight && that_present_maxWeight))
          return false;
        if (this.maxWeight != that.maxWeight)
          return false;
      }

      boolean this_present_minWeight = true;
      boolean that_present_minWeight = true;
      if (this_present_minWeight || that_present_minWeight) {
        if (!(this_present_minWeight && that_present_minWeight))
          return false;
        if (this.minWeight != that.minWeight)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enableStdp_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enableStdp_args typedOther = (enableStdp_args)other;

      lastComparison = Boolean.valueOf(isSetPrefire()).compareTo(isSetPrefire());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(prefire, typedOther.prefire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetPostfire()).compareTo(isSetPostfire());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(postfire, typedOther.postfire);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetMaxWeight()).compareTo(isSetMaxWeight());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(maxWeight, typedOther.maxWeight);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetMinWeight()).compareTo(isSetMinWeight());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(minWeight, typedOther.minWeight);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case PREFIRE:
            if (field.type == TType.LIST) {
              {
                TList _list8 = iprot.readListBegin();
                this.prefire = new ArrayList<Double>(_list8.size);
                for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                {
                  double _elem10;
                  _elem10 = iprot.readDouble();
                  this.prefire.add(_elem10);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case POSTFIRE:
            if (field.type == TType.LIST) {
              {
                TList _list11 = iprot.readListBegin();
                this.postfire = new ArrayList<Double>(_list11.size);
                for (int _i12 = 0; _i12 < _list11.size; ++_i12)
                {
                  double _elem13;
                  _elem13 = iprot.readDouble();
                  this.postfire.add(_elem13);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case MAXWEIGHT:
            if (field.type == TType.DOUBLE) {
              this.maxWeight = iprot.readDouble();
              setMaxWeightIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case MINWEIGHT:
            if (field.type == TType.DOUBLE) {
              this.minWeight = iprot.readDouble();
              setMinWeightIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.prefire != null) {
        oprot.writeFieldBegin(PREFIRE_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.DOUBLE, this.prefire.size()));
          for (double _iter14 : this.prefire)          {
            oprot.writeDouble(_iter14);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.postfire != null) {
        oprot.writeFieldBegin(POSTFIRE_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.DOUBLE, this.postfire.size()));
          for (double _iter15 : this.postfire)          {
            oprot.writeDouble(_iter15);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(MAX_WEIGHT_FIELD_DESC);
      oprot.writeDouble(this.maxWeight);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(MIN_WEIGHT_FIELD_DESC);
      oprot.writeDouble(this.minWeight);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enableStdp_args(");
      boolean first = true;

      sb.append("prefire:");
      if (this.prefire == null) {
        sb.append("null");
      } else {
        sb.append(this.prefire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("postfire:");
      if (this.postfire == null) {
        sb.append("null");
      } else {
        sb.append(this.postfire);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("maxWeight:");
      sb.append(this.maxWeight);
      first = false;
      if (!first) sb.append(", ");
      sb.append("minWeight:");
      sb.append(this.minWeight);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enableStdp_result implements TBase, java.io.Serializable, Cloneable, Comparable<enableStdp_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("enableStdp_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enableStdp_result.class, metaDataMap);
    }

    public enableStdp_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enableStdp_result(enableStdp_result other) {
    }

    @Override
    public enableStdp_result clone() {
      return new enableStdp_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enableStdp_result)
        return this.equals((enableStdp_result)that);
      return false;
    }

    public boolean equals(enableStdp_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enableStdp_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enableStdp_result typedOther = (enableStdp_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enableStdp_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enablePipelining_args implements TBase, java.io.Serializable, Cloneable, Comparable<enablePipelining_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("enablePipelining_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enablePipelining_args.class, metaDataMap);
    }

    public enablePipelining_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enablePipelining_args(enablePipelining_args other) {
    }

    @Override
    public enablePipelining_args clone() {
      return new enablePipelining_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enablePipelining_args)
        return this.equals((enablePipelining_args)that);
      return false;
    }

    public boolean equals(enablePipelining_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enablePipelining_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enablePipelining_args typedOther = (enablePipelining_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enablePipelining_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class enablePipelining_result implements TBase, java.io.Serializable, Cloneable, Comparable<enablePipelining_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("enablePipelining_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(enablePipelining_result.class, metaDataMap);
    }

    public enablePipelining_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public enablePipelining_result(enablePipelining_result other) {
    }

    @Override
    public enablePipelining_result clone() {
      return new enablePipelining_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof enablePipelining_result)
        return this.equals((enablePipelining_result)that);
      return false;
    }

    public boolean equals(enablePipelining_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(enablePipelining_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      enablePipelining_result typedOther = (enablePipelining_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("enablePipelining_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class pipelineLength_args implements TBase, java.io.Serializable, Cloneable, Comparable<pipelineLength_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("pipelineLength_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(pipelineLength_args.class, metaDataMap);
    }

    public pipelineLength_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pipelineLength_args(pipelineLength_args other) {
    }

    @Override
    public pipelineLength_args clone() {
      return new pipelineLength_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pipelineLength_args)
        return this.equals((pipelineLength_args)that);
      return false;
    }

    public boolean equals(pipelineLength_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(pipelineLength_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pipelineLength_args typedOther = (pipelineLength_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("pipelineLength_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class pipelineLength_result implements TBase, java.io.Serializable, Cloneable, Comparable<pipelineLength_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("pipelineLength_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);

    public PipelineLength success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, PipelineLength.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(pipelineLength_result.class, metaDataMap);
    }

    public pipelineLength_result() {
    }

    public pipelineLength_result(
      PipelineLength success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public pipelineLength_result(pipelineLength_result other) {
      if (other.isSetSuccess()) {
        this.success = new PipelineLength(other.success);
      }
    }

    @Override
    public pipelineLength_result clone() {
      return new pipelineLength_result(this);
    }

    public PipelineLength getSuccess() {
      return this.success;
    }

    public pipelineLength_result setSuccess(PipelineLength success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((PipelineLength)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof pipelineLength_result)
        return this.equals((pipelineLength_result)that);
      return false;
    }

    public boolean equals(pipelineLength_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(pipelineLength_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      pipelineLength_result typedOther = (pipelineLength_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.STRUCT) {
              this.success = new PipelineLength();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("pipelineLength_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class disableStdp_args implements TBase, java.io.Serializable, Cloneable, Comparable<disableStdp_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("disableStdp_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(disableStdp_args.class, metaDataMap);
    }

    public disableStdp_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public disableStdp_args(disableStdp_args other) {
    }

    @Override
    public disableStdp_args clone() {
      return new disableStdp_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof disableStdp_args)
        return this.equals((disableStdp_args)that);
      return false;
    }

    public boolean equals(disableStdp_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(disableStdp_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      disableStdp_args typedOther = (disableStdp_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("disableStdp_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class disableStdp_result implements TBase, java.io.Serializable, Cloneable, Comparable<disableStdp_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("disableStdp_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(disableStdp_result.class, metaDataMap);
    }

    public disableStdp_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public disableStdp_result(disableStdp_result other) {
    }

    @Override
    public disableStdp_result clone() {
      return new disableStdp_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof disableStdp_result)
        return this.equals((disableStdp_result)that);
      return false;
    }

    public boolean equals(disableStdp_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(disableStdp_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      disableStdp_result typedOther = (disableStdp_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("disableStdp_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class addNeuron_args implements TBase, java.io.Serializable, Cloneable, Comparable<addNeuron_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("addNeuron_args");
    private static final TField NEURON_FIELD_DESC = new TField("neuron", TType.STRUCT, (short)1);

    public IzhNeuron neuron;
    public static final int NEURON = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(NEURON, new FieldMetaData("neuron", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, IzhNeuron.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(addNeuron_args.class, metaDataMap);
    }

    public addNeuron_args() {
    }

    public addNeuron_args(
      IzhNeuron neuron)
    {
      this();
      this.neuron = neuron;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addNeuron_args(addNeuron_args other) {
      if (other.isSetNeuron()) {
        this.neuron = new IzhNeuron(other.neuron);
      }
    }

    @Override
    public addNeuron_args clone() {
      return new addNeuron_args(this);
    }

    public IzhNeuron getNeuron() {
      return this.neuron;
    }

    public addNeuron_args setNeuron(IzhNeuron neuron) {
      this.neuron = neuron;
      return this;
    }

    public void unsetNeuron() {
      this.neuron = null;
    }

    // Returns true if field neuron is set (has been asigned a value) and false otherwise
    public boolean isSetNeuron() {
      return this.neuron != null;
    }

    public void setNeuronIsSet(boolean value) {
      if (!value) {
        this.neuron = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case NEURON:
        if (value == null) {
          unsetNeuron();
        } else {
          setNeuron((IzhNeuron)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case NEURON:
        return getNeuron();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case NEURON:
        return isSetNeuron();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addNeuron_args)
        return this.equals((addNeuron_args)that);
      return false;
    }

    public boolean equals(addNeuron_args that) {
      if (that == null)
        return false;

      boolean this_present_neuron = true && this.isSetNeuron();
      boolean that_present_neuron = true && that.isSetNeuron();
      if (this_present_neuron || that_present_neuron) {
        if (!(this_present_neuron && that_present_neuron))
          return false;
        if (!this.neuron.equals(that.neuron))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(addNeuron_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addNeuron_args typedOther = (addNeuron_args)other;

      lastComparison = Boolean.valueOf(isSetNeuron()).compareTo(isSetNeuron());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(neuron, typedOther.neuron);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case NEURON:
            if (field.type == TType.STRUCT) {
              this.neuron = new IzhNeuron();
              this.neuron.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.neuron != null) {
        oprot.writeFieldBegin(NEURON_FIELD_DESC);
        this.neuron.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("addNeuron_args(");
      boolean first = true;

      sb.append("neuron:");
      if (this.neuron == null) {
        sb.append("null");
      } else {
        sb.append(this.neuron);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class addNeuron_result implements TBase, java.io.Serializable, Cloneable, Comparable<addNeuron_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("addNeuron_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(addNeuron_result.class, metaDataMap);
    }

    public addNeuron_result() {
    }

    public addNeuron_result(
      ConstructionError err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public addNeuron_result(addNeuron_result other) {
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public addNeuron_result clone() {
      return new addNeuron_result(this);
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public addNeuron_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof addNeuron_result)
        return this.equals((addNeuron_result)that);
      return false;
    }

    public boolean equals(addNeuron_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(addNeuron_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      addNeuron_result typedOther = (addNeuron_result)other;

      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("addNeuron_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class startSimulation_args implements TBase, java.io.Serializable, Cloneable, Comparable<startSimulation_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("startSimulation_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(startSimulation_args.class, metaDataMap);
    }

    public startSimulation_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public startSimulation_args(startSimulation_args other) {
    }

    @Override
    public startSimulation_args clone() {
      return new startSimulation_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof startSimulation_args)
        return this.equals((startSimulation_args)that);
      return false;
    }

    public boolean equals(startSimulation_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(startSimulation_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      startSimulation_args typedOther = (startSimulation_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("startSimulation_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class startSimulation_result implements TBase, java.io.Serializable, Cloneable, Comparable<startSimulation_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("startSimulation_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(startSimulation_result.class, metaDataMap);
    }

    public startSimulation_result() {
    }

    public startSimulation_result(
      ConstructionError err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public startSimulation_result(startSimulation_result other) {
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public startSimulation_result clone() {
      return new startSimulation_result(this);
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public startSimulation_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof startSimulation_result)
        return this.equals((startSimulation_result)that);
      return false;
    }

    public boolean equals(startSimulation_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(startSimulation_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      startSimulation_result typedOther = (startSimulation_result)other;

      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("startSimulation_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class run_args implements TBase, java.io.Serializable, Cloneable, Comparable<run_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("run_args");
    private static final TField STIM_FIELD_DESC = new TField("stim", TType.LIST, (short)1);

    public List<Stimulus> stim;
    public static final int STIM = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(STIM, new FieldMetaData("stim", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Stimulus.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(run_args.class, metaDataMap);
    }

    public run_args() {
    }

    public run_args(
      List<Stimulus> stim)
    {
      this();
      this.stim = stim;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public run_args(run_args other) {
      if (other.isSetStim()) {
        List<Stimulus> __this__stim = new ArrayList<Stimulus>();
        for (Stimulus other_element : other.stim) {
          __this__stim.add(new Stimulus(other_element));
        }
        this.stim = __this__stim;
      }
    }

    @Override
    public run_args clone() {
      return new run_args(this);
    }

    public List<Stimulus> getStim() {
      return this.stim;
    }

    public run_args setStim(List<Stimulus> stim) {
      this.stim = stim;
      return this;
    }

    public void unsetStim() {
      this.stim = null;
    }

    // Returns true if field stim is set (has been asigned a value) and false otherwise
    public boolean isSetStim() {
      return this.stim != null;
    }

    public void setStimIsSet(boolean value) {
      if (!value) {
        this.stim = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case STIM:
        if (value == null) {
          unsetStim();
        } else {
          setStim((List<Stimulus>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case STIM:
        return getStim();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case STIM:
        return isSetStim();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof run_args)
        return this.equals((run_args)that);
      return false;
    }

    public boolean equals(run_args that) {
      if (that == null)
        return false;

      boolean this_present_stim = true && this.isSetStim();
      boolean that_present_stim = true && that.isSetStim();
      if (this_present_stim || that_present_stim) {
        if (!(this_present_stim && that_present_stim))
          return false;
        if (!this.stim.equals(that.stim))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(run_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      run_args typedOther = (run_args)other;

      lastComparison = Boolean.valueOf(isSetStim()).compareTo(isSetStim());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(stim, typedOther.stim);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case STIM:
            if (field.type == TType.LIST) {
              {
                TList _list16 = iprot.readListBegin();
                this.stim = new ArrayList<Stimulus>(_list16.size);
                for (int _i17 = 0; _i17 < _list16.size; ++_i17)
                {
                  Stimulus _elem18;
                  _elem18 = new Stimulus();
                  _elem18.read(iprot);
                  this.stim.add(_elem18);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.stim != null) {
        oprot.writeFieldBegin(STIM_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.stim.size()));
          for (Stimulus _iter19 : this.stim)          {
            _iter19.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("run_args(");
      boolean first = true;

      sb.append("stim:");
      if (this.stim == null) {
        sb.append("null");
      } else {
        sb.append(this.stim);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class run_result implements TBase, java.io.Serializable, Cloneable, Comparable<run_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("run_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public List<List<Integer>> success;
    public static final int SUCCESS = 0;
    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.LIST))));
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(run_result.class, metaDataMap);
    }

    public run_result() {
    }

    public run_result(
      List<List<Integer>> success,
      ConstructionError err)
    {
      this();
      this.success = success;
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public run_result(run_result other) {
      if (other.isSetSuccess()) {
        List<List<Integer>> __this__success = new ArrayList<List<Integer>>();
        for (List<Integer> other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public run_result clone() {
      return new run_result(this);
    }

    public List<List<Integer>> getSuccess() {
      return this.success;
    }

    public run_result setSuccess(List<List<Integer>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public run_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<List<Integer>>)value);
        }
        break;

      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof run_result)
        return this.equals((run_result)that);
      return false;
    }

    public boolean equals(run_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(run_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      run_result typedOther = (run_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.LIST) {
              {
                TList _list20 = iprot.readListBegin();
                this.success = new ArrayList<List<Integer>>(_list20.size);
                for (int _i21 = 0; _i21 < _list20.size; ++_i21)
                {
                  List<Integer> _elem22;
                  {
                    TList _list23 = iprot.readListBegin();
                    _elem22 = new ArrayList<Integer>(_list23.size);
                    for (int _i24 = 0; _i24 < _list23.size; ++_i24)
                    {
                      int _elem25;
                      _elem25 = iprot.readI32();
                      _elem22.add(_elem25);
                    }
                    iprot.readListEnd();
                  }
                  this.success.add(_elem22);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.LIST, this.success.size()));
          for (List<Integer> _iter26 : this.success)          {
            {
              oprot.writeListBegin(new TList(TType.I32, _iter26.size()));
              for (int _iter27 : _iter26)              {
                oprot.writeI32(_iter27);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("run_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class applyStdp_args implements TBase, java.io.Serializable, Cloneable, Comparable<applyStdp_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("applyStdp_args");
    private static final TField REWARD_FIELD_DESC = new TField("reward", TType.DOUBLE, (short)1);

    public double reward;
    public static final int REWARD = 1;

    // isset id assignments
    private static final int __REWARD_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(REWARD, new FieldMetaData("reward", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.DOUBLE)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(applyStdp_args.class, metaDataMap);
    }

    public applyStdp_args() {
    }

    public applyStdp_args(
      double reward)
    {
      this();
      this.reward = reward;
      setRewardIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public applyStdp_args(applyStdp_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.reward = other.reward;
    }

    @Override
    public applyStdp_args clone() {
      return new applyStdp_args(this);
    }

    public double getReward() {
      return this.reward;
    }

    public applyStdp_args setReward(double reward) {
      this.reward = reward;
      setRewardIsSet(true);
      return this;
    }

    public void unsetReward() {
      __isset_bit_vector.clear(__REWARD_ISSET_ID);
    }

    // Returns true if field reward is set (has been asigned a value) and false otherwise
    public boolean isSetReward() {
      return __isset_bit_vector.get(__REWARD_ISSET_ID);
    }

    public void setRewardIsSet(boolean value) {
      __isset_bit_vector.set(__REWARD_ISSET_ID, value);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case REWARD:
        if (value == null) {
          unsetReward();
        } else {
          setReward((Double)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case REWARD:
        return new Double(getReward());

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case REWARD:
        return isSetReward();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof applyStdp_args)
        return this.equals((applyStdp_args)that);
      return false;
    }

    public boolean equals(applyStdp_args that) {
      if (that == null)
        return false;

      boolean this_present_reward = true;
      boolean that_present_reward = true;
      if (this_present_reward || that_present_reward) {
        if (!(this_present_reward && that_present_reward))
          return false;
        if (this.reward != that.reward)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(applyStdp_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      applyStdp_args typedOther = (applyStdp_args)other;

      lastComparison = Boolean.valueOf(isSetReward()).compareTo(isSetReward());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(reward, typedOther.reward);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case REWARD:
            if (field.type == TType.DOUBLE) {
              this.reward = iprot.readDouble();
              setRewardIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(REWARD_FIELD_DESC);
      oprot.writeDouble(this.reward);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("applyStdp_args(");
      boolean first = true;

      sb.append("reward:");
      sb.append(this.reward);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class applyStdp_result implements TBase, java.io.Serializable, Cloneable, Comparable<applyStdp_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("applyStdp_result");
    private static final TField ERR_FIELD_DESC = new TField("err", TType.STRUCT, (short)1);

    public ConstructionError err;
    public static final int ERR = 1;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(ERR, new FieldMetaData("err", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(applyStdp_result.class, metaDataMap);
    }

    public applyStdp_result() {
    }

    public applyStdp_result(
      ConstructionError err)
    {
      this();
      this.err = err;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public applyStdp_result(applyStdp_result other) {
      if (other.isSetErr()) {
        this.err = new ConstructionError(other.err);
      }
    }

    @Override
    public applyStdp_result clone() {
      return new applyStdp_result(this);
    }

    public ConstructionError getErr() {
      return this.err;
    }

    public applyStdp_result setErr(ConstructionError err) {
      this.err = err;
      return this;
    }

    public void unsetErr() {
      this.err = null;
    }

    // Returns true if field err is set (has been asigned a value) and false otherwise
    public boolean isSetErr() {
      return this.err != null;
    }

    public void setErrIsSet(boolean value) {
      if (!value) {
        this.err = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case ERR:
        if (value == null) {
          unsetErr();
        } else {
          setErr((ConstructionError)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case ERR:
        return getErr();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case ERR:
        return isSetErr();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof applyStdp_result)
        return this.equals((applyStdp_result)that);
      return false;
    }

    public boolean equals(applyStdp_result that) {
      if (that == null)
        return false;

      boolean this_present_err = true && this.isSetErr();
      boolean that_present_err = true && that.isSetErr();
      if (this_present_err || that_present_err) {
        if (!(this_present_err && that_present_err))
          return false;
        if (!this.err.equals(that.err))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(applyStdp_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      applyStdp_result typedOther = (applyStdp_result)other;

      lastComparison = Boolean.valueOf(isSetErr()).compareTo(isSetErr());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(err, typedOther.err);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ERR:
            if (field.type == TType.STRUCT) {
              this.err = new ConstructionError();
              this.err.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetErr()) {
        oprot.writeFieldBegin(ERR_FIELD_DESC);
        this.err.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("applyStdp_result(");
      boolean first = true;

      sb.append("err:");
      if (this.err == null) {
        sb.append("null");
      } else {
        sb.append(this.err);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getConnectivity_args implements TBase, java.io.Serializable, Cloneable, Comparable<getConnectivity_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("getConnectivity_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getConnectivity_args.class, metaDataMap);
    }

    public getConnectivity_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConnectivity_args(getConnectivity_args other) {
    }

    @Override
    public getConnectivity_args clone() {
      return new getConnectivity_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConnectivity_args)
        return this.equals((getConnectivity_args)that);
      return false;
    }

    public boolean equals(getConnectivity_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getConnectivity_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getConnectivity_args typedOther = (getConnectivity_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getConnectivity_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class getConnectivity_result implements TBase, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getConnectivity_result");
    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);

    public Map<Integer,List<Synapse>> success;
    public static final int SUCCESS = 0;

    // isset id assignments

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new MapMetaData(TType.MAP, 
              new FieldValueMetaData(TType.I32), 
              new FieldValueMetaData(TType.LIST))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(getConnectivity_result.class, metaDataMap);
    }

    public getConnectivity_result() {
    }

    public getConnectivity_result(
      Map<Integer,List<Synapse>> success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getConnectivity_result(getConnectivity_result other) {
      if (other.isSetSuccess()) {
        Map<Integer,List<Synapse>> __this__success = new HashMap<Integer,List<Synapse>>();
        for (Map.Entry<Integer, List<Synapse>> other_element : other.success.entrySet()) {

          Integer other_element_key = other_element.getKey();
          List<Synapse> other_element_value = other_element.getValue();

          Integer __this__success_copy_key = other_element_key;

          List<Synapse> __this__success_copy_value = other_element_value;

          __this__success.put(__this__success_copy_key, __this__success_copy_value);
        }
        this.success = __this__success;
      }
    }

    @Override
    public getConnectivity_result clone() {
      return new getConnectivity_result(this);
    }

    public Map<Integer,List<Synapse>> getSuccess() {
      return this.success;
    }

    public getConnectivity_result setSuccess(Map<Integer,List<Synapse>> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    // Returns true if field success is set (has been asigned a value) and false otherwise
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<Integer,List<Synapse>>)value);
        }
        break;

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return getSuccess();

      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getConnectivity_result)
        return this.equals((getConnectivity_result)that);
      return false;
    }

    public boolean equals(getConnectivity_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case SUCCESS:
            if (field.type == TType.MAP) {
              {
                TMap _map28 = iprot.readMapBegin();
                this.success = new HashMap<Integer,List<Synapse>>(2*_map28.size);
                for (int _i29 = 0; _i29 < _map28.size; ++_i29)
                {
                  int _key30;
                  List<Synapse> _val31;
                  _key30 = iprot.readI32();
                  {
                    TList _list32 = iprot.readListBegin();
                    _val31 = new ArrayList<Synapse>(_list32.size);
                    for (int _i33 = 0; _i33 < _list32.size; ++_i33)
                    {
                      Synapse _elem34;
                      _elem34 = new Synapse();
                      _elem34.read(iprot);
                      _val31.add(_elem34);
                    }
                    iprot.readListEnd();
                  }
                  this.success.put(_key30, _val31);
                }
                iprot.readMapEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.I32, TType.LIST, this.success.size()));
          for (Map.Entry<Integer, List<Synapse>> _iter35 : this.success.entrySet())          {
            oprot.writeI32(_iter35.getKey());
            {
              oprot.writeListBegin(new TList(TType.STRUCT, _iter35.getValue().size()));
              for (Synapse _iter36 : _iter35.getValue())              {
                _iter36.write(oprot);
              }
              oprot.writeListEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getConnectivity_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class stopSimulation_args implements TBase, java.io.Serializable, Cloneable, Comparable<stopSimulation_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("stopSimulation_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(stopSimulation_args.class, metaDataMap);
    }

    public stopSimulation_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stopSimulation_args(stopSimulation_args other) {
    }

    @Override
    public stopSimulation_args clone() {
      return new stopSimulation_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stopSimulation_args)
        return this.equals((stopSimulation_args)that);
      return false;
    }

    public boolean equals(stopSimulation_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(stopSimulation_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      stopSimulation_args typedOther = (stopSimulation_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("stopSimulation_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class stopSimulation_result implements TBase, java.io.Serializable, Cloneable, Comparable<stopSimulation_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("stopSimulation_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(stopSimulation_result.class, metaDataMap);
    }

    public stopSimulation_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public stopSimulation_result(stopSimulation_result other) {
    }

    @Override
    public stopSimulation_result clone() {
      return new stopSimulation_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof stopSimulation_result)
        return this.equals((stopSimulation_result)that);
      return false;
    }

    public boolean equals(stopSimulation_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(stopSimulation_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      stopSimulation_result typedOther = (stopSimulation_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("stopSimulation_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class reset_args implements TBase, java.io.Serializable, Cloneable, Comparable<reset_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("reset_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(reset_args.class, metaDataMap);
    }

    public reset_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public reset_args(reset_args other) {
    }

    @Override
    public reset_args clone() {
      return new reset_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof reset_args)
        return this.equals((reset_args)that);
      return false;
    }

    public boolean equals(reset_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(reset_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      reset_args typedOther = (reset_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("reset_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class reset_result implements TBase, java.io.Serializable, Cloneable, Comparable<reset_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("reset_result");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(reset_result.class, metaDataMap);
    }

    public reset_result() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public reset_result(reset_result other) {
    }

    @Override
    public reset_result clone() {
      return new reset_result(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof reset_result)
        return this.equals((reset_result)that);
      return false;
    }

    public boolean equals(reset_result that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(reset_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      reset_result typedOther = (reset_result)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("reset_result(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

  public static class terminate_args implements TBase, java.io.Serializable, Cloneable, Comparable<terminate_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("terminate_args");

    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(terminate_args.class, metaDataMap);
    }

    public terminate_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public terminate_args(terminate_args other) {
    }

    @Override
    public terminate_args clone() {
      return new terminate_args(this);
    }

    public void setFieldValue(int fieldID, Object value) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    public Object getFieldValue(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
    public boolean isSet(int fieldID) {
      switch (fieldID) {
      default:
        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
      }
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof terminate_args)
        return this.equals((terminate_args)that);
      return false;
    }

    public boolean equals(terminate_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(terminate_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      terminate_args typedOther = (terminate_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("terminate_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
