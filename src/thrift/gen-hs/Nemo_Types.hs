-----------------------------------------------------------------
-- Autogenerated by Thrift                                     --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Nemo_Types where
import Thrift
import Data.Typeable ( Typeable )
import Control.Exception
import qualified Data.Map as Map
import qualified Data.Set as Set
import Data.Int
type Axon = [Synapse]

type Firing = [Int]

data Synapse = Synapse{f_Synapse_target :: Maybe Int,f_Synapse_delay :: Maybe Int,f_Synapse_weight :: Maybe Double,f_Synapse_plastic :: Maybe Bool} deriving (Show,Eq,Ord,Typeable)
write_Synapse oprot rec = do
  writeStructBegin oprot "Synapse"
  case f_Synapse_target rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("target",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Synapse_delay rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("delay",T_I16,2)
    writeI16 oprot _v
    writeFieldEnd oprot}
  case f_Synapse_weight rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("weight",T_DOUBLE,3)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_Synapse_plastic rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("plastic",T_BOOL,4)
    writeBool oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Synapse_fields iprot rec = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return rec else
    case _id4 of 
      1 -> if _t3 == T_I32 then do
        s <- readI32 iprot
        read_Synapse_fields iprot rec{f_Synapse_target=Just s}
        else do
          skip iprot _t3
          read_Synapse_fields iprot rec
      2 -> if _t3 == T_I16 then do
        s <- readI16 iprot
        read_Synapse_fields iprot rec{f_Synapse_delay=Just s}
        else do
          skip iprot _t3
          read_Synapse_fields iprot rec
      3 -> if _t3 == T_DOUBLE then do
        s <- readDouble iprot
        read_Synapse_fields iprot rec{f_Synapse_weight=Just s}
        else do
          skip iprot _t3
          read_Synapse_fields iprot rec
      4 -> if _t3 == T_BOOL then do
        s <- readBool iprot
        read_Synapse_fields iprot rec{f_Synapse_plastic=Just s}
        else do
          skip iprot _t3
          read_Synapse_fields iprot rec
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Synapse_fields iprot rec
read_Synapse iprot = do
  readStructBegin iprot
  rec <- read_Synapse_fields iprot (Synapse{f_Synapse_target=Nothing,f_Synapse_delay=Nothing,f_Synapse_weight=Nothing,f_Synapse_plastic=Nothing})
  readStructEnd iprot
  return rec
data IzhNeuron = IzhNeuron{f_IzhNeuron_index :: Maybe Int,f_IzhNeuron_a :: Maybe Double,f_IzhNeuron_b :: Maybe Double,f_IzhNeuron_c :: Maybe Double,f_IzhNeuron_d :: Maybe Double,f_IzhNeuron_u :: Maybe Double,f_IzhNeuron_v :: Maybe Double,f_IzhNeuron_axon :: Maybe [Synapse]} deriving (Show,Eq,Ord,Typeable)
write_IzhNeuron oprot rec = do
  writeStructBegin oprot "IzhNeuron"
  case f_IzhNeuron_index rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("index",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_IzhNeuron_a rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("a",T_DOUBLE,2)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_IzhNeuron_b rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("b",T_DOUBLE,3)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_IzhNeuron_c rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("c",T_DOUBLE,4)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_IzhNeuron_d rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("d",T_DOUBLE,5)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_IzhNeuron_u rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("u",T_DOUBLE,6)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_IzhNeuron_v rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("v",T_DOUBLE,7)
    writeDouble oprot _v
    writeFieldEnd oprot}
  case f_IzhNeuron_axon rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("axon",T_LIST,8)
    (let {f [] = return (); f (_viter7:t) = do {write_Synapse oprot _viter7;f t}} in do {writeListBegin oprot (T_STRUCT,length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_IzhNeuron_fields iprot rec = do
  (_,_t9,_id10) <- readFieldBegin iprot
  if _t9 == T_STOP then return rec else
    case _id10 of 
      1 -> if _t9 == T_I32 then do
        s <- readI32 iprot
        read_IzhNeuron_fields iprot rec{f_IzhNeuron_index=Just s}
        else do
          skip iprot _t9
          read_IzhNeuron_fields iprot rec
      2 -> if _t9 == T_DOUBLE then do
        s <- readDouble iprot
        read_IzhNeuron_fields iprot rec{f_IzhNeuron_a=Just s}
        else do
          skip iprot _t9
          read_IzhNeuron_fields iprot rec
      3 -> if _t9 == T_DOUBLE then do
        s <- readDouble iprot
        read_IzhNeuron_fields iprot rec{f_IzhNeuron_b=Just s}
        else do
          skip iprot _t9
          read_IzhNeuron_fields iprot rec
      4 -> if _t9 == T_DOUBLE then do
        s <- readDouble iprot
        read_IzhNeuron_fields iprot rec{f_IzhNeuron_c=Just s}
        else do
          skip iprot _t9
          read_IzhNeuron_fields iprot rec
      5 -> if _t9 == T_DOUBLE then do
        s <- readDouble iprot
        read_IzhNeuron_fields iprot rec{f_IzhNeuron_d=Just s}
        else do
          skip iprot _t9
          read_IzhNeuron_fields iprot rec
      6 -> if _t9 == T_DOUBLE then do
        s <- readDouble iprot
        read_IzhNeuron_fields iprot rec{f_IzhNeuron_u=Just s}
        else do
          skip iprot _t9
          read_IzhNeuron_fields iprot rec
      7 -> if _t9 == T_DOUBLE then do
        s <- readDouble iprot
        read_IzhNeuron_fields iprot rec{f_IzhNeuron_v=Just s}
        else do
          skip iprot _t9
          read_IzhNeuron_fields iprot rec
      8 -> if _t9 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- (read_Synapse iprot);r <- f (n-1); return $ v:r}} in do {(_etype14,_size11) <- readListBegin iprot; f _size11})
        read_IzhNeuron_fields iprot rec{f_IzhNeuron_axon=Just s}
        else do
          skip iprot _t9
          read_IzhNeuron_fields iprot rec
      _ -> do
        skip iprot _t9
        readFieldEnd iprot
        read_IzhNeuron_fields iprot rec
read_IzhNeuron iprot = do
  readStructBegin iprot
  rec <- read_IzhNeuron_fields iprot (IzhNeuron{f_IzhNeuron_index=Nothing,f_IzhNeuron_a=Nothing,f_IzhNeuron_b=Nothing,f_IzhNeuron_c=Nothing,f_IzhNeuron_d=Nothing,f_IzhNeuron_u=Nothing,f_IzhNeuron_v=Nothing,f_IzhNeuron_axon=Nothing})
  readStructEnd iprot
  return rec
data Stimulus = Stimulus{f_Stimulus_firing :: Maybe [Int]} deriving (Show,Eq,Ord,Typeable)
write_Stimulus oprot rec = do
  writeStructBegin oprot "Stimulus"
  case f_Stimulus_firing rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("firing",T_LIST,1)
    (let {f [] = return (); f (_viter18:t) = do {writeI32 oprot _viter18;f t}} in do {writeListBegin oprot (T_I32,length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Stimulus_fields iprot rec = do
  (_,_t20,_id21) <- readFieldBegin iprot
  if _t20 == T_STOP then return rec else
    case _id21 of 
      1 -> if _t20 == T_LIST then do
        s <- (let {f 0 = return []; f n = do {v <- readI32 iprot;r <- f (n-1); return $ v:r}} in do {(_etype25,_size22) <- readListBegin iprot; f _size22})
        read_Stimulus_fields iprot rec{f_Stimulus_firing=Just s}
        else do
          skip iprot _t20
          read_Stimulus_fields iprot rec
      _ -> do
        skip iprot _t20
        readFieldEnd iprot
        read_Stimulus_fields iprot rec
read_Stimulus iprot = do
  readStructBegin iprot
  rec <- read_Stimulus_fields iprot (Stimulus{f_Stimulus_firing=Nothing})
  readStructEnd iprot
  return rec
data ConstructionError = ConstructionError{f_ConstructionError_msg :: Maybe String} deriving (Show,Eq,Ord,Typeable)
instance Exception ConstructionError
write_ConstructionError oprot rec = do
  writeStructBegin oprot "ConstructionError"
  case f_ConstructionError_msg rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("msg",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ConstructionError_fields iprot rec = do
  (_,_t30,_id31) <- readFieldBegin iprot
  if _t30 == T_STOP then return rec else
    case _id31 of 
      1 -> if _t30 == T_STRING then do
        s <- readString iprot
        read_ConstructionError_fields iprot rec{f_ConstructionError_msg=Just s}
        else do
          skip iprot _t30
          read_ConstructionError_fields iprot rec
      _ -> do
        skip iprot _t30
        readFieldEnd iprot
        read_ConstructionError_fields iprot rec
read_ConstructionError iprot = do
  readStructBegin iprot
  rec <- read_ConstructionError_fields iprot (ConstructionError{f_ConstructionError_msg=Nothing})
  readStructEnd iprot
  return rec
data PipelineLength = PipelineLength{f_PipelineLength_input :: Maybe Int,f_PipelineLength_output :: Maybe Int} deriving (Show,Eq,Ord,Typeable)
write_PipelineLength oprot rec = do
  writeStructBegin oprot "PipelineLength"
  case f_PipelineLength_input rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("input",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_PipelineLength_output rec of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("output",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_PipelineLength_fields iprot rec = do
  (_,_t35,_id36) <- readFieldBegin iprot
  if _t35 == T_STOP then return rec else
    case _id36 of 
      1 -> if _t35 == T_I32 then do
        s <- readI32 iprot
        read_PipelineLength_fields iprot rec{f_PipelineLength_input=Just s}
        else do
          skip iprot _t35
          read_PipelineLength_fields iprot rec
      2 -> if _t35 == T_I32 then do
        s <- readI32 iprot
        read_PipelineLength_fields iprot rec{f_PipelineLength_output=Just s}
        else do
          skip iprot _t35
          read_PipelineLength_fields iprot rec
      _ -> do
        skip iprot _t35
        readFieldEnd iprot
        read_PipelineLength_fields iprot rec
read_PipelineLength iprot = do
  readStructBegin iprot
  rec <- read_PipelineLength_fields iprot (PipelineLength{f_PipelineLength_input=Nothing,f_PipelineLength_output=Nothing})
  readStructEnd iprot
  return rec
