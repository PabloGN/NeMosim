function nemoSetNetwork(a, b, c, d, u, v, targets, delays, weights, plastic)

	if ~exist('plastic')
		plastic = logical(zeros(size(targets)));
	end;

	global NEMO_NEURONS_A;
	global NEMO_NEURONS_B;
	global NEMO_NEURONS_C;
	global NEMO_NEURONS_D;
	global NEMO_NEURONS_U;
	global NEMO_NEURONS_V;

	NEMO_NEURONS_A = a;
	NEMO_NEURONS_B = b;
	NEMO_NEURONS_C = c;
	NEMO_NEURONS_D = d;
	NEMO_NEURONS_U = u;
	NEMO_NEURONS_V = v;

	global NEMO_CM; % sparse connectivity matrix, stored by delay
	global NEMO_MAX_DELAY;

	NEMO_MAX_DELAY = max(max(delays));
	fprintf('Creating forward connectivity matrix...');
	NEMO_CM = sparsify(targets, delays, weights, NEMO_MAX_DELAY);
	fprintf('done\n');
	ncount = length(a);
	% TODO: which way should we orient
	% TODO: limit to size of STDP window

	global NEMO_RECENT_FIRING;
	NEMO_RECENT_FIRING = logical(zeros(ncount, 64));

	fprintf('Creating reverse connectivity matrix...');
	set_reverse(targets, delays, plastic, ncount);
	fprintf('done\n');
end



function set_reverse(targets, delays, plastic, ncount)

	global NEMO_RCM_D; % delay for each synapse
	global NEMO_RCM_N; % index for each presyanptic

	NEMO_RCM_D = cell(ncount);
	NEMO_RCM_N = cell(ncount);

	[ncount scount] = size(targets);
	pre = repmat([1:ncount]', scount, 1);

	% Ignore all synapses marked invalid (target 0)
	% Also ignore synapses not marked as 'plastic'
	valid = find(targets ~= 0 & plastic ~= 0);

	pre_v = pre(valid);

	targets_v = int32(reshape(targets, ncount*scount, 1));
	NEMO_RCM_N = accumarray(targets_v(valid), pre_v, [ncount 1], @(x) {x'});

	delays_v = int32(reshape(delays, ncount*scount, 1));
	NEMO_RCM_D = accumarray(targets_v(valid), delays_v(valid), [ncount 1], @(x) {x'});
end
