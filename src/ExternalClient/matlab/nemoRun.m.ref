function fired = nemoRun(nsteps, fstim)

	% TODO: remove debugging code
	fid = fopen('firing.dat','wt');
	%fid = 1;

	global NEMO_NEURONS_A;
	global NEMO_STDP_ENABLED;
	global NEMO_CYCLE;

	fired = [];
	verbose = false;
	ncount = size(NEMO_NEURONS_A,1);

	for t=1:nsteps
		fs = firing_stimulus(fstim, t);
		I = deliver_spikes(NEMO_CYCLE, ncount);
		f_new = update_state(verbose, fid, t-1, NEMO_CYCLE, fs, I);
		if NEMO_STDP_ENABLED
			accumulateStdpStatistics(verbose, fid, NEMO_CYCLE);
		end;
		fired = [fired; f_new];
		NEMO_CYCLE = NEMO_CYCLE + 1;
	end;

	fclose(fid);
end



% The user specifies stimulus for a whole block of cycles. Return the once
% relevant to *this* cycle.
function stim = firing_stimulus(stimulus, t)
	stim = [];
	if ~isempty(stimulus)
		stim = stimulus(stimulus(:,1) == t);
	end;
end



% Deliver all spikes due for arrival this cycle, and return vector of
% accumulated current from incoming spikes for each neuron
function I = deliver_spikes(t, ncount)

	global NEMO_RECENT_FIRING;
	global NEMO_CM;
	global NEMO_MAX_DELAY;

	I = zeros(ncount, 1);
	history_len = size(NEMO_RECENT_FIRING, 2);

	for delay=1:NEMO_MAX_DELAY
		weights = NEMO_CM{delay};
		pres = find(NEMO_RECENT_FIRING(:, rf_idx(t-delay, history_len)));
		I_acc = weights(:,pres);
		I = I + sum(I_acc,2);
	end;
end



% Update the state of each neuron
function firings_out = update_state(verbose, fid, t0, t, stimulated, I)

	global NEMO_NEURONS_A; a = NEMO_NEURONS_A;
	global NEMO_NEURONS_B; b = NEMO_NEURONS_B;
	global NEMO_NEURONS_C; c = NEMO_NEURONS_C;
	global NEMO_NEURONS_D; d = NEMO_NEURONS_D;

	global NEMO_NEURONS_U;
	global NEMO_NEURONS_V;

	% Update v and u using Izhikevich's model in increments of tau
	emsteps = 4;     % euler method steps
	tau = 1/emsteps; % ms per euler method step

	for k=1:emsteps
		quiet = find(NEMO_NEURONS_V < 30);
		NEMO_NEURONS_V(quiet) = NEMO_NEURONS_V(quiet) + ...
			tau*((0.04*NEMO_NEURONS_V(quiet)+5) .* NEMO_NEURONS_V(quiet) ...
				+ 140 - NEMO_NEURONS_U(quiet) + I(quiet));
		NEMO_NEURONS_U(quiet) = NEMO_NEURONS_U(quiet) + ...
			tau*(a(quiet).*(b(quiet).*NEMO_NEURONS_V(quiet)-NEMO_NEURONS_U(quiet)));
	end;

	fired = find(NEMO_NEURONS_V >= 30);
	fired = sort([fired, stimulated]);
	if verbose && ~isempty(fired)
		global NEMO_CYCLE;
		for i=1:length(fired)
			fprintf(fid, 'c%u: n%u fired\n', NEMO_CYCLE, fired(i));
		end;
	end;

	if ~isempty(fired)
		NEMO_NEURONS_V(fired) = c(fired);
		NEMO_NEURONS_U(fired) = NEMO_NEURONS_U(fired) + d(fired);
	end;

	firings_out = [t0+0*fired, fired];

	global NEMO_RTS_FIRED;
	NEMO_RTS_FIRED = NEMO_RTS_FIRED + numel(fired);

	% Set recent firing history (a rotating buffer)
	global NEMO_RECENT_FIRING;
	history_len = size(NEMO_RECENT_FIRING, 2);
	now = rf_idx(t, history_len);
	NEMO_RECENT_FIRING(:, now) = 0;
	if ~isempty(fired)
		NEMO_RECENT_FIRING(fired, now) = 1;
	end;
end



function accumulateStdpStatistics(verbose, fid, t)

	global NEMO_STDP_PREFIRE;
	global NEMO_STDP_POSTFIRE;
	global NEMO_STDP_ACC;
	global NEMO_RECENT_FIRING;
	global NEMO_RCM_D;
	global NEMO_RCM_N;

	global NEMO_RTS_LTP;
	global NEMO_RTS_LTD;

	% Get all neurons which fired in the middle of the STDP window
	tf = int32(t - length(NEMO_STDP_POSTFIRE));

	% All potentially relevent post-synaptic firings

	global NEMO_RECENT_FIRING;
	history_len = size(NEMO_RECENT_FIRING, 2);
	post_firings = find(NEMO_RECENT_FIRING(:, rf_idx(tf, history_len)));

	t_offset = - 1 + idivide(t, int32(64)) * 64;

	stdp_pre_window = length(NEMO_STDP_PREFIRE);
	stdp_post_window = length(NEMO_STDP_POSTFIRE);

	for pf = 1:size(post_firings,1) 

		post = post_firings(pf);    % index of postsynaptic neurons which fired
		pres = NEMO_RCM_N{post};    % all neurons presynaptic to 'post' ...
		ds = NEMO_RCM_D{post};      % ... and all their delays

		for p = 1:numel(pres)

			d = ds(p);

			% all relevant firings of presynaptic
			% TODO: pre-compute the indices which could be of interest here
			% TODO: make sure the lookup is in the 'fast' direction here
			i_fire = int32(find(NEMO_RECENT_FIRING(pres(p),:)));

			if isempty(i_fire)
				continue;
			end;

			% compute actual times
			t_fire = i_fire + t_offset;
			t_fire(t_fire > t) = t_fire(t_fire > t) - 64;

			% compute dt
			dt_all = t_fire + d - tf;

			% split into prefire and postfire
			dt_prefire = -dt_all(dt_all <= 0 & dt_all > -stdp_pre_window) + 1;
			dt_postfire = dt_all(dt_all > 0 & dt_all <= stdp_post_window);

			% TODO: deal with potentiation and depression separately

			w_diff = 0;
			if ~isempty(dt_prefire)
				dt_pre = dt_prefire(find(abs(dt_prefire) == min(abs(dt_prefire))));
				w_diff = NEMO_STDP_PREFIRE(dt_pre);
				NEMO_RTS_LTP = NEMO_RTS_LTP + 1;
			end;

			if ~isempty(dt_postfire)
				dt_post = dt_postfire(find(abs(dt_postfire) == min(abs(dt_postfire))));
				w_diff = w_diff + NEMO_STDP_POSTFIRE(dt_post);
				NEMO_RTS_LTD = NEMO_RTS_LTD + 1;
			end;

			% TODO: change format of the accumulator, and update accumulator outside the inner loop
			NEMO_STDP_ACC{d}(post,pres(p)) = NEMO_STDP_ACC{d}(post,pres(p)) + w_diff;
		end;
	end;
end




% Print potentiation or depression to stdout, if in verbose mode
function logStdp(fid, type, t, post, dt_arr)
	% TODO: use sparse format here for dt_arr
	for pre = 1:length(dt_arr)
		dt = dt_arr(pre);
		if dt >= 1
			fprintf(fid, 'c%u %s: %u->%u dt=%d\n', t, type, pre, post, dt-1);
		end;
	end;
end


function logStdp0(fid, type, t, post, dt_arr)
	% TODO: use sparse format here for dt_arr
	if ~isempty(dt_arr)
		for i = 1:size(dt_arr,1)
			pre = dt_arr(i,1);
			dt = dt_arr(i,2);
			%dt = dt_arr(pre);
			fprintf(fid, 'c%u %s: %u->%u dt=%d\n', t, type, pre, post, dt-1);
		end;
	end;
end



% Return index in range [1,bufsz] into circular firing buffer of size sz.
function idx = rf_idx(idx0, sz)
	idx = mod(idx0, sz) + 1;
end
