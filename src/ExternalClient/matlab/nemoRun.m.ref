function fired = nemoRun(nsteps, fstim)

	% TODO: remove debugging code
	% TODO: use globals for file handles
	%fid = fopen('firing.dat','wt');
	fid = 1;

	global NEMO_NEURONS_A;
	global NEMO_STDP_ENABLED;
	global NEMO_CYCLE;

	fired = [];
	verbose = false;
	ncount = size(NEMO_NEURONS_A,1);

	for t=1:nsteps
		fs = firing_stimulus(fstim, t);
		I = deliver_spikes(NEMO_CYCLE, ncount);
		f_new = update_state(verbose, fid, t-1, NEMO_CYCLE, fs, I);
		if NEMO_STDP_ENABLED
			accumulateStdpStatistics(verbose, fid, NEMO_CYCLE);
		end;
		fired = [fired; f_new];
		NEMO_CYCLE = NEMO_CYCLE + 1;
	end;

	%fclose(fid);
end



% The user specifies stimulus for a whole block of cycles. Return the once
% relevant to *this* cycle.
function stim = firing_stimulus(stimulus, t)
	stim = [];
	if ~isempty(stimulus)
		stim = stimulus(stimulus(:,1) == t, 2);
	end;
end



% Deliver all spikes due for arrival this cycle, and return vector of
% accumulated current from incoming spikes for each neuron
function I = deliver_spikes(t, ncount)

	global NEMO_RECENT_FIRING;
	global NEMO_CM;
	global NEMO_MAX_DELAY;

	I = zeros(ncount, 1);
	history_len = size(NEMO_RECENT_FIRING, 2);

	for delay=1:NEMO_MAX_DELAY
		weights = NEMO_CM{delay};
		pres = find(NEMO_RECENT_FIRING(:, rf_idx(t-delay, history_len)));
		I_acc = weights(:,pres);
		I = I + sum(I_acc,2);
	end;
end



% Update the state of each neuron
function firings_out = update_state(verbose, fid, t0, t, stimulated, I)

	global NEMO_NEURONS_A; a = NEMO_NEURONS_A;
	global NEMO_NEURONS_B; b = NEMO_NEURONS_B;
	global NEMO_NEURONS_C; c = NEMO_NEURONS_C;
	global NEMO_NEURONS_D; d = NEMO_NEURONS_D;

	global NEMO_NEURONS_U;
	global NEMO_NEURONS_V;

	% Update v and u using Izhikevich's model in increments of tau
	emsteps = 4;     % euler method steps
	tau = 1/emsteps; % ms per euler method step

	for k=1:emsteps
		quiet = find(NEMO_NEURONS_V < 30);
		NEMO_NEURONS_V(quiet) = NEMO_NEURONS_V(quiet) + ...
			tau*((0.04*NEMO_NEURONS_V(quiet)+5) .* NEMO_NEURONS_V(quiet) ...
				+ 140 - NEMO_NEURONS_U(quiet) + I(quiet));
		NEMO_NEURONS_U(quiet) = NEMO_NEURONS_U(quiet) + ...
			tau*(a(quiet).*(b(quiet).*NEMO_NEURONS_V(quiet)-NEMO_NEURONS_U(quiet)));
	end;

	fired = find(NEMO_NEURONS_V >= 30);
	fired = sort([fired; stimulated]);
	if verbose && ~isempty(fired)
		global NEMO_CYCLE;
		for i=1:length(fired)
			fprintf(fid, 'c%u: n%u fired\n', NEMO_CYCLE, fired(i));
		end;
	end;

	if ~isempty(fired)
		NEMO_NEURONS_V(fired) = c(fired);
		NEMO_NEURONS_U(fired) = NEMO_NEURONS_U(fired) + d(fired);
	end;

	firings_out = [t0+1+0*fired, fired];

	global NEMO_RTS_FIRED;
	NEMO_RTS_FIRED = NEMO_RTS_FIRED + numel(fired);

	% Set recent firing history (a rotating buffer)
	global NEMO_RECENT_FIRING;
	history_len = size(NEMO_RECENT_FIRING, 2);
	now = rf_idx(t, history_len);
	NEMO_RECENT_FIRING(:, now) = 0;
	if ~isempty(fired)
		NEMO_RECENT_FIRING(fired, now) = 1;
	end;
end



function accumulateStdpStatistics(verbose, fid, t)

	global NEMO_STDP_PREFIRE;
	global NEMO_STDP_POSTFIRE;
	global NEMO_STDP_ACC;
	global NEMO_RECENT_FIRING;
	global NEMO_RCM_D;
	global NEMO_RCM_N;
	global NEMO_MAX_DELAY;

	global NEMO_RTS_LTP;
	global NEMO_RTS_LTD;

	% Get all neurons which fired in the middle of the STDP window
	tf = int32(t - length(NEMO_STDP_POSTFIRE));

	% All potentially relevent post-synaptic firings

	global NEMO_RECENT_FIRING;
	history_len = size(NEMO_RECENT_FIRING, 2);
	post_firings = find(NEMO_RECENT_FIRING(:, rf_idx(tf, history_len)));

	% Each column in the recent firing history corresponds to a particular
	% recent cycle. This is a circular buffer where the beginning (current
	% cycle) moves around. The t_buffer vector contains the cycle number
	% corresponding to each column in the buffer.
	t_buffer = int32(0:63) + idivide(t, int32(64)) * 64;
	t_buffer(t_buffer > t) = t_buffer(t_buffer > t) - 64;

	stdp_pre_window = length(NEMO_STDP_PREFIRE);
	stdp_post_window = length(NEMO_STDP_POSTFIRE);
	stdp_len = stdp_pre_window + stdp_post_window;

	% The spikes that fall into the potentiation and the depression parts of
	% the STDP window are handled separately. We classify spikes based on the
	% 'dt' values. The lookuptable (dt -> class) is precomputed here:
	% The classes are
	% 1: invalid
	% 2: potentiation
	% 3: depression

	stdp_pre = ones(stdp_pre_window, 1);
	stdp_pre(sign(NEMO_STDP_PREFIRE) == 1) = 2;
	stdp_pre(sign(NEMO_STDP_PREFIRE) == -1) = 3;

	stdp_post = ones(stdp_pre_window, 1);
	stdp_post(sign(NEMO_STDP_POSTFIRE) == 1) = 2;
	stdp_post(sign(NEMO_STDP_POSTFIRE) == -1) = 3;

	stdp_regions = [ones(history_len-stdp_len, 1); ... % spikes arriving before STDP window
	                stdp_pre; ...                      % spikes arriving prior to postsynaptic firing
	                zeros(1, 1); ...                   % dt = 0, this should not happend
	                stdp_post; ...                     % spikes arriving after postsynaptic firing
	                ones(NEMO_MAX_DELAY, 1)];          % spikes arrivaing after STDP window
	stdp_offset = history_len - stdp_len + stdp_pre_window + 1;

    for pf = 1:size(post_firings,1) 

		post = post_firings(pf);

		% All recent firings of presynaptic neurons. Each row corresponds to a
		% single synapse. There may be several spikes for each synapse       
		f_pre = NEMO_RECENT_FIRING(NEMO_RCM_N{post},:);                    
        
		valid = (f_pre ~= 0);
		if(~any(any(valid)))
			continue;
		end   
        
		% Synapses (indices into reverse connectivity) for which we need to
		% check dt.
		synapses = find(any(f_pre'));                                      
        
		% i_pres and i_tfired are vectors which together describe all the
		% synapses which may take part in STDP. i_tfired are the bins in the
		% recent firing history each spike falls in under.
		[i_pres, i_tfired] = find(f_pre(synapses,:) ~= 0);                 
        
		% Since we have store f_pre in row-major order we get incorrect %
		% orientation on i_pres and i_tfired if we only have a single row.
		% Therefore, force into column format.
		i_pres = i_pres(:);
        
		%    firing time (pre)     + delay                              - firing time (post)
		dt = t_buffer(i_tfired(:)) + NEMO_RCM_D{post}(synapses(i_pres)) - tf;
           

		% Make negative indices 1-based and positive rather than 0-based
		dt(dt <= 0) = dt(dt <= 0) - 1;

		% Split spikes into presynaptic and postsynaptic regions as described above.
		subs = stdp_regions(dt + stdp_offset);
            
		% now get minimum for the presynaptic neurons with active spikes
		% TODO: share the transpose code with earlier loop exit
		len = length(find(any(f_pre')));
		dt_sorted = accumarray([i_pres, subs], abs(dt), [len 3], @min);
		potentiating = (dt_sorted(:,2) ~= 0);
		depressing = (dt_sorted(:,3) ~= 0);

		% TODO: do the counting conditionally
		NEMO_RTS_LTP = NEMO_RTS_LTP + length(find(potentiating));
		NEMO_RTS_LTD = NEMO_RTS_LTD + length(find(depressing));

        % TODO: store the lookup tables in column format from the start
		% The 'accumarray' constructs the weight difference vector, with one
		% entry for each modified synapse. This will merge synapses with both
		% potentiation and depression.
		NEMO_STDP_ACC{post}(synapses) = ...
			NEMO_STDP_ACC{post}(synapses) + ...
			accumarray([find(potentiating); find(depressing)],...
				[NEMO_STDP_PREFIRE(dt_sorted(potentiating,2))'; NEMO_STDP_POSTFIRE(dt_sorted(depressing,3))'],...
				[len 1])';
   end
end




% Print potentiation or depression to stdout, if in verbose mode
function logStdp(fid, type, t, post, dt_arr)
	% TODO: use sparse format here for dt_arr
	for pre = 1:length(dt_arr)
		dt = dt_arr(pre);
		if dt >= 1
			fprintf(fid, 'c%u %s: %u->%u dt=%d\n', t, type, pre, post, dt-1);
		end;
	end;
end


function logStdp0(fid, type, t, post, dt_arr)
	% TODO: use sparse format here for dt_arr
	if ~isempty(dt_arr)
		for i = 1:size(dt_arr,1)
			pre = dt_arr(i,1);
			dt = dt_arr(i,2);
			%dt = dt_arr(pre);
			fprintf(fid, 'c%u %s: %u->%u dt=%d\n', t, type, pre, post, dt-1);
		end;
	end;
end



% Return index in range [1,bufsz] into circular firing buffer of size sz.
function idx = rf_idx(idx0, sz)
	idx = mod(idx0, sz) + 1;
end
