function nemoApplySTDP(reward)

	global NEMO_CM;
	global NEMO_STDP_ACC;
	global NEMO_MAX_DELAY;
	global NEMO_STDP_MAX_WEIGHT;
	global NEMO_STDP_MIN_WEIGHT;
	global NEMO_CYCLE;

	for d=1:NEMO_MAX_DELAY

		% TODO: make use of 'plastic' matrix here
		% TODO: could prune synapses which have reached zero here

		changed = find(NEMO_STDP_ACC{d} ~= 0);
		w = NEMO_CM{d}(changed);
		w_init = w;

		if(reward == 1) % common case
			w = w + NEMO_STDP_ACC{d}(changed);
		elseif(reward ~= 0)
			w = w + NEMO_STDP_ACC{d}(changed) * reward;
		end

		% excitatory synapses
		w(w > NEMO_STDP_MAX_WEIGHT) = NEMO_STDP_MAX_WEIGHT;
		w(w < 0 & w_init >= 0) = 0;

		% inhibitory synapses
		w(w < NEMO_STDP_MIN_WEIGHT) = NEMO_STDP_MIN_WEIGHT;
		w(w > 0 & w_init <= 0) = 0;

		NEMO_CM{d}(changed) = w;
	end;
end



% TODO: add back tracing
% Print (to stdout) all weight matrix modifications
function logSTDP(t, acc)
	ind = find(acc ~= 0);
	for i=1:length(ind)
		[post, pre] = ind2sub(size(acc), ind);
		fprintf('c%u: stdp %u->%u w=%f\n', t, pre(i), post(i), acc(ind(i)));
	end;
end
