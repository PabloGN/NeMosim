#ifndef _IZHIKEVICH_H_
#define _IZHIKEVICH_H_

//! \todo remove use of vector to make this a pure c interface

#include <stdio.h>

//#define NEURONS_PER_BLOCK 256

typedef unsigned char uchar;

//! \todo define error codes for API calls


enum SimStatus {
	SIM_OK,
	SIM_ERROR
};


/* Return required size of character array to hold n densely packed bits */
//#define BIT_VECTOR_SIZE(n) (n > 0 ? ((n-1)/8)+1 : 0)

enum HandlerError {
	HANDLER_OK,
	HANDLER_ERROR
};


enum ReportFlags {
	REPORT_TIMING = 0x1,
	REPORT_FIRING = 0x2,
	REPORT_MEMORY = 0x4,
	REPORT_POSTSYNAPTIC = 0x8
};



typedef class Simulation* CUDA_NSIM_HANDLE;

/* Request a handle through which the simulation can be set up */
CUDA_NSIM_HANDLE nsimGetHandle();

void nsimFreeHandle(CUDA_NSIM_HANDLE);

/*! Add neuronal cluster to simulation and return an index which can be used to
 * set probes */
int nsimAddCluster(CUDA_NSIM_HANDLE, class Cluster*);



//! \todo add back. only use both forms of cpp is enabled
#if 0
/*! Add neuronal cluster to simulation and return an index which can be used to
 * set probes.
 *
 * \param n number of neurons in cluster
 * \param v n-vector of neuron state v for each neuron
 * \param u n-vector of neuron state u for each neuron
 * \param a n-vector of neuron parameter a for each neuron
 * \param b n-vector of neuron parameter b for each neuron
 * \param c n-vector of neuron parameter c for each neuron
 * \param d n-vector of neuron parameter d for each neuron
 * \param weights Densely packed n*n connectivity weight matrix 
 */
int nsimAddCluster(CUDA_SIM_HANDLE sim, int n, 
	float* v, float* u, float* a, float* b, float* c, float* d, float* weights);
#endif



/*! \param currentScaling
 * 		Multiplier for all currents in network
 */
SimStatus nsimRun(CUDA_NSIM_HANDLE,
		int simCycles, 
		int updatesPerInvocation,
		int reportFlags, 
		float currentScaling,
		void(*currentStimulus)(float*, int, int),
		void(*firingStimulus)(char*, int, int),
		HandlerError(*firingHandler)(FILE*, char*, int, int, uchar)=NULL,
		FILE* firingFile=stdout,
		HandlerError(*vHandler)(FILE*, float*, int)=NULL,
		FILE* vFile=stdout);
		//void(*uHandler)(FILE*, float*, int)=NULL);

/*! The caller can specify a cluster to probe during execution. The cluster
 * index should be one returned by nsimAddCluster. An invalid cluster index
 * returns an error. */ 
void nsimProbeCluster(CUDA_NSIM_HANDLE, int clusterIndex);

void nsimFreeHandle(CUDA_NSIM_HANDLE);



/* The firing data generated by the simulation can be handled by the calling
 * program, by passing a pointer to a handler function. This handler should
 * have prototype int(*)(FILE* file, char* firing, int n), where file is the
 * file pointer passed to the run function, firing is the array of firing
 * neurons, and n is the length of this array. The handler should return
 * HandlerError. 
 * 
 * Below are a few handlers which might be useful
 */

/*! Print firing neurons using terminal colours */
HandlerError printFiringTermColour(FILE*, char* firing, int n, int cycle, uchar final);

/*! Print 0 or 1 for each neuron */
HandlerError 
printFiringRaw(FILE* outfile, char* firing, int n, int cycle, uchar final);

/*! Check firing against input file */
HandlerError 
verifyFiring(FILE* infile, char* firing, int n, int cycle, uchar final);


/*! Print firing errors using terminal colours */
HandlerError 
printErrors(FILE* infile, char* firing, int n, int cycle, uchar final);



/*! Print time-neuron pairs for each firing neuron (one entry per line). This
 * is suitable for e.g. gnuplot */
HandlerError 
printFiringCoordinates(FILE* outfile, char* firing, int n, int cycle, uchar final);



/* Other data, such as 'v' is dealt with in the same way. */

/*! Print n series of v data in column format */ 
HandlerError printVData(FILE* outfile, float* v, int n);


#endif
