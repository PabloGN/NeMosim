#ifndef DISPATCH_TABLE_CU_H
#define DISPATCH_TABLE_CU_H

/* The L0 connectivity matrix is split up into small rectangular chunks, one
 * for each partition for each delay, The address and pitch of each of these is
 * stored in a texture. 
 * 
 * On the device we use 32-bit pointers, which allows up to 4GB of memory. This
 * is already the capacity of C1060, so it's not terribly future-proof.
 * However, we'll only ever need to address well-alligned data, in practice
 * alligned to 256-dword alligned data (i.e. 2kB alligned). Therefore, 32b
 * should allow us to address 2^41 bytes = 2TB. 
 *
 * In device emulation, device pointers are the same as host pointer, which are
 * most commonly 64 bits. Therefore the reference type is in this case slightly
 * wider, with a somewhat hacky packing scheme.
 */

//! \todo changed addressing to 2kB allignment, to future-proof code

#include <vector>
#include <cuda_runtime.h>

#ifdef __DEVICE_EMULATION__
typedef uint4 fcm_ref_t; // one of the fields is unused, but uint3 can't be used for textures
#else
typedef uint2 fcm_ref_t;
#endif


/*! Set up a dispatch table (partition x delay -> address) for the forward
 * level 0 connectivity matrix, in texture memory.
 *
 * \param h_table
 *		Vector containing the dispatch table in row-major form (width =
 *		delayCount, height = partitionCount)
 * \return
 *		Pointer to CUDA array holding the dispatch table data. The caller is
 *		responsible for freeing this memory (using cudaFreeArray).
 */
cudaArray*
f_setDispatchTable(
		size_t partitionCount,
		size_t delayCount,
		const std::vector<fcm_ref_t>& h_table);


/*! 
 * \param devicePtr
 *		Byte address of start of a block in the forward connectivity matrix 
 * \param pitch
 *		The pitch (in words) of this block 
 */
fcm_ref_t fcm_packReference(void* devicePtr, size_t pitch);

#endif
